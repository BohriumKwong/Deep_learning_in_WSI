
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>SPAMS’s python interface documentation &#8212; SPAMS 1 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="#">SPAMS 1 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="spams-s-python-interface-documentation">
<h1>SPAMS’s python interface documentation<a class="headerlink" href="#spams-s-python-interface-documentation" title="Permalink to this headline">¶</a></h1>
<p>Contents:</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#spams.sort" title="spams.sort"><code class="xref py py-obj docutils literal"><span class="pre">sort</span></code></a>(X[,&nbsp;mode])</td>
<td>sort the elements of X using quicksort</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#spams.calcAAt" title="spams.calcAAt"><code class="xref py py-obj docutils literal"><span class="pre">calcAAt</span></code></a>(A)</td>
<td>Compute efficiently AAt = A*A’, when A is sparse    and has a lot more columns than rows.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#spams.calcXAt" title="spams.calcXAt"><code class="xref py py-obj docutils literal"><span class="pre">calcXAt</span></code></a>(X,&nbsp;A)</td>
<td>Compute efficiently XAt = X*A’, when A is sparse and has a    lot more columns than rows.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#spams.calcXY" title="spams.calcXY"><code class="xref py py-obj docutils literal"><span class="pre">calcXY</span></code></a>(X,&nbsp;Y)</td>
<td>Compute Z=XY using the BLAS library used by SPAMS.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#spams.calcXYt" title="spams.calcXYt"><code class="xref py py-obj docutils literal"><span class="pre">calcXYt</span></code></a>(X,&nbsp;Y)</td>
<td>Compute Z=XY’ using the BLAS library used by SPAMS.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#spams.calcXtY" title="spams.calcXtY"><code class="xref py py-obj docutils literal"><span class="pre">calcXtY</span></code></a>(X,&nbsp;Y)</td>
<td>Compute Z=X’Y using the BLAS library used by SPAMS.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#spams.bayer" title="spams.bayer"><code class="xref py py-obj docutils literal"><span class="pre">bayer</span></code></a>(X,&nbsp;offset)</td>
<td>bayer applies a Bayer pattern to an image X.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#spams.conjGrad" title="spams.conjGrad"><code class="xref py py-obj docutils literal"><span class="pre">conjGrad</span></code></a>(A,&nbsp;b[,&nbsp;x0,&nbsp;tol,&nbsp;itermax])</td>
<td>Conjugate gradient algorithm, sometimes faster than the     equivalent python function solve.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#spams.invSym" title="spams.invSym"><code class="xref py py-obj docutils literal"><span class="pre">invSym</span></code></a>(A)</td>
<td>returns the inverse of a symmetric matrix A</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#spams.normalize" title="spams.normalize"><code class="xref py py-obj docutils literal"><span class="pre">normalize</span></code></a>(A)</td>
<td>rescale the columns of X so that they have</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#spams.sparseProject" title="spams.sparseProject"><code class="xref py py-obj docutils literal"><span class="pre">sparseProject</span></code></a>(U[,&nbsp;thrs,&nbsp;mode,&nbsp;lambda1,&nbsp;…])</td>
<td>sparseProject solves various optimization</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#spams.lasso" title="spams.lasso"><code class="xref py py-obj docutils literal"><span class="pre">lasso</span></code></a>(X[,&nbsp;D,&nbsp;Q,&nbsp;q,&nbsp;return_reg_path,&nbsp;L,&nbsp;…])</td>
<td>lasso is an efficient implementation of the</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#spams.lassoMask" title="spams.lassoMask"><code class="xref py py-obj docutils literal"><span class="pre">lassoMask</span></code></a>(X,&nbsp;D,&nbsp;B[,&nbsp;L,&nbsp;lambda1,&nbsp;lambda2,&nbsp;…])</td>
<td>lasso is a variant of lasso that handles</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#spams.lassoWeighted" title="spams.lassoWeighted"><code class="xref py py-obj docutils literal"><span class="pre">lassoWeighted</span></code></a>(X,&nbsp;D,&nbsp;W[,&nbsp;L,&nbsp;lambda1,&nbsp;mode,&nbsp;…])</td>
<td>lassoWeighted is an efficient implementation of the</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#spams.omp" title="spams.omp"><code class="xref py py-obj docutils literal"><span class="pre">omp</span></code></a>(X,&nbsp;D[,&nbsp;L,&nbsp;eps,&nbsp;lambda1,&nbsp;…])</td>
<td>omp is an efficient implementation of the</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#spams.ompMask" title="spams.ompMask"><code class="xref py py-obj docutils literal"><span class="pre">ompMask</span></code></a>(X,&nbsp;D,&nbsp;B[,&nbsp;L,&nbsp;eps,&nbsp;lambda1,&nbsp;…])</td>
<td>ompMask is a variant of omp that allow using</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#spams.cd" title="spams.cd"><code class="xref py py-obj docutils literal"><span class="pre">cd</span></code></a>(X,&nbsp;D,&nbsp;A0[,&nbsp;lambda1,&nbsp;mode,&nbsp;itermax,&nbsp;tol,&nbsp;…])</td>
<td>cd addresses l1-decomposition problem with a</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#spams.somp" title="spams.somp"><code class="xref py py-obj docutils literal"><span class="pre">somp</span></code></a>(X,&nbsp;D,&nbsp;list_groups[,&nbsp;L,&nbsp;eps,&nbsp;numThreads])</td>
<td>somp is an efficient implementation of a</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#spams.l1L2BCD" title="spams.l1L2BCD"><code class="xref py py-obj docutils literal"><span class="pre">l1L2BCD</span></code></a>(X,&nbsp;D,&nbsp;alpha0,&nbsp;list_groups[,&nbsp;…])</td>
<td>l1L2BCD is a solver for a</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#spams.fistaFlat" title="spams.fistaFlat"><code class="xref py py-obj docutils literal"><span class="pre">fistaFlat</span></code></a>(Y,&nbsp;X,&nbsp;W0[,&nbsp;return_optim_info,&nbsp;…])</td>
<td>fistaFlat solves sparse regularized problems.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#spams.fistaTree" title="spams.fistaTree"><code class="xref py py-obj docutils literal"><span class="pre">fistaTree</span></code></a>(Y,&nbsp;X,&nbsp;W0,&nbsp;tree[,&nbsp;…])</td>
<td>fistaTree solves sparse regularized problems.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#spams.fistaGraph" title="spams.fistaGraph"><code class="xref py py-obj docutils literal"><span class="pre">fistaGraph</span></code></a>(Y,&nbsp;X,&nbsp;W0,&nbsp;graph[,&nbsp;…])</td>
<td>fistaGraph solves sparse regularized problems.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#spams.proximalFlat" title="spams.proximalFlat"><code class="xref py py-obj docutils literal"><span class="pre">proximalFlat</span></code></a>(U[,&nbsp;return_val_loss,&nbsp;…])</td>
<td>proximalFlat computes proximal operators. Depending</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#spams.proximalTree" title="spams.proximalTree"><code class="xref py py-obj docutils literal"><span class="pre">proximalTree</span></code></a>(U,&nbsp;tree[,&nbsp;return_val_loss,&nbsp;…])</td>
<td>proximalTree computes a proximal operator. Depending</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#spams.proximalGraph" title="spams.proximalGraph"><code class="xref py py-obj docutils literal"><span class="pre">proximalGraph</span></code></a>(U,&nbsp;graph[,&nbsp;return_val_loss,&nbsp;…])</td>
<td>proximalGraph computes a proximal operator. Depending</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#spams.trainDL" title="spams.trainDL"><code class="xref py py-obj docutils literal"><span class="pre">trainDL</span></code></a>(X[,&nbsp;return_model,&nbsp;model,&nbsp;D,&nbsp;…])</td>
<td>trainDL is an efficient implementation of the</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#spams.structTrainDL" title="spams.structTrainDL"><code class="xref py py-obj docutils literal"><span class="pre">structTrainDL</span></code></a>(X[,&nbsp;return_model,&nbsp;model,&nbsp;D,&nbsp;…])</td>
<td>structTrainDL is an efficient implementation of the</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#spams.trainDL_Memory" title="spams.trainDL_Memory"><code class="xref py py-obj docutils literal"><span class="pre">trainDL_Memory</span></code></a>(X[,&nbsp;D,&nbsp;numThreads,&nbsp;…])</td>
<td>trainDL_Memory is an efficient but memory consuming</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#spams.nmf" title="spams.nmf"><code class="xref py py-obj docutils literal"><span class="pre">nmf</span></code></a>(X[,&nbsp;return_lasso,&nbsp;model,&nbsp;numThreads,&nbsp;…])</td>
<td>trainDL is an efficient implementation of the</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#spams.nnsc" title="spams.nnsc"><code class="xref py py-obj docutils literal"><span class="pre">nnsc</span></code></a>(X[,&nbsp;return_lasso,&nbsp;model,&nbsp;lambda1,&nbsp;…])</td>
<td>trainDL is an efficient implementation of the</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#spams.archetypalAnalysis" title="spams.archetypalAnalysis"><code class="xref py py-obj docutils literal"><span class="pre">archetypalAnalysis</span></code></a>(X[,&nbsp;p,&nbsp;Z0,&nbsp;returnAB,&nbsp;…])</td>
<td>documentation to appear soon</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#spams.decompSimplex" title="spams.decompSimplex"><code class="xref py py-obj docutils literal"><span class="pre">decompSimplex</span></code></a>(X,&nbsp;Z[,&nbsp;computeXtX,&nbsp;numThreads])</td>
<td>documentation to appear soon</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#spams.simpleGroupTree" title="spams.simpleGroupTree"><code class="xref py py-obj docutils literal"><span class="pre">simpleGroupTree</span></code></a>(degrees)</td>
<td>makes a structure representing a tree given the</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#spams.readGroupStruct" title="spams.readGroupStruct"><code class="xref py py-obj docutils literal"><span class="pre">readGroupStruct</span></code></a>(file)</td>
<td>reads a text file describing “simply” the structure of groups</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#spams.groupStructOfString" title="spams.groupStructOfString"><code class="xref py py-obj docutils literal"><span class="pre">groupStructOfString</span></code></a>(s)</td>
<td>decode a multi-line string describing “simply” the structure of groups</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#spams.graphOfGroupStruct" title="spams.graphOfGroupStruct"><code class="xref py py-obj docutils literal"><span class="pre">graphOfGroupStruct</span></code></a>(gstruct)</td>
<td>converts a group structure into the graph structure</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#spams.treeOfGroupStruct" title="spams.treeOfGroupStruct"><code class="xref py py-obj docutils literal"><span class="pre">treeOfGroupStruct</span></code></a>(gstruct)</td>
<td>converts a group structure into the tree structure</td>
</tr>
</tbody>
</table>
<div class="section" id="sort">
<h2>sort<a class="headerlink" href="#sort" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.sort">
<code class="descclassname">spams.</code><code class="descname">sort</code><span class="sig-paren">(</span><em>X</em>, <em>mode=True</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>sort the elements of X using quicksort</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> – double vector of size n</li>
<li><strong>mode</strong> – false for decreasing order (true by default)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>Y</strong>: double  vector of size n</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2010 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="calcaat">
<h2>calcAAt<a class="headerlink" href="#calcaat" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.calcAAt">
<code class="descclassname">spams.</code><code class="descname">calcAAt</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.calcAAt" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Compute efficiently AAt = A*A’, when A is sparse </dt>
<dd>and has a lot more columns than rows. In some cases, it is
up to 20 times faster than the equivalent python expression
AAt=A*A’;</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> – double sparse m x n matrix</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>AAt</strong>: double m x m matrix</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2009 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="calcxat">
<h2>calcXAt<a class="headerlink" href="#calcxat" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.calcXAt">
<code class="descclassname">spams.</code><code class="descname">calcXAt</code><span class="sig-paren">(</span><em>X</em>, <em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.calcXAt" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Compute efficiently XAt = X*A’, when A is sparse and has a </dt>
<dd>lot more columns than rows. In some cases, it is up to 20 times 
faster than the equivalent python expression;</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> – double m x n matrix</li>
<li><strong>A</strong> – double sparse p x n matrix</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>XAt</strong>: double m x p matrix</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2009 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="calcxy">
<h2>calcXY<a class="headerlink" href="#calcxy" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.calcXY">
<code class="descclassname">spams.</code><code class="descname">calcXY</code><span class="sig-paren">(</span><em>X</em>, <em>Y</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.calcXY" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Z=XY using the BLAS library used by SPAMS.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> – double m x n matrix</li>
<li><strong>Y</strong> – double n x p matrix</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>Z</strong>: double m x p matrix</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2009 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="calcxyt">
<h2>calcXYt<a class="headerlink" href="#calcxyt" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.calcXYt">
<code class="descclassname">spams.</code><code class="descname">calcXYt</code><span class="sig-paren">(</span><em>X</em>, <em>Y</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.calcXYt" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Z=XY’ using the BLAS library used by SPAMS.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> – double m x n matrix</li>
<li><strong>Y</strong> – double p x n matrix</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>Z</strong>: double m x p matrix</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2009 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="calcxty">
<h2>calcXtY<a class="headerlink" href="#calcxty" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.calcXtY">
<code class="descclassname">spams.</code><code class="descname">calcXtY</code><span class="sig-paren">(</span><em>X</em>, <em>Y</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.calcXtY" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Z=X’Y using the BLAS library used by SPAMS.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> – double n x m matrix</li>
<li><strong>Y</strong> – double n x p matrix</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>Z</strong>: double m x p matrix</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2009 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="bayer">
<h2>bayer<a class="headerlink" href="#bayer" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.bayer">
<code class="descclassname">spams.</code><code class="descname">bayer</code><span class="sig-paren">(</span><em>X</em>, <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.bayer" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>bayer applies a Bayer pattern to an image X.</dt>
<dd>There are four possible offsets.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> – double m x n matrix</li>
<li><strong>offset</strong> – scalar, 0,1,2 or 3</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>Y</strong>: double m x m matrix</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2009 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="conjgrad">
<h2>conjGrad<a class="headerlink" href="#conjgrad" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.conjGrad">
<code class="descclassname">spams.</code><code class="descname">conjGrad</code><span class="sig-paren">(</span><em>A</em>, <em>b</em>, <em>x0=None</em>, <em>tol=1e-10</em>, <em>itermax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.conjGrad" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Conjugate gradient algorithm, sometimes faster than the </dt>
<dd>equivalent python function solve. In order to solve Ax=b;</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> – double square n x n matrix. HAS TO BE POSITIVE DEFINITE</li>
<li><strong>b</strong> – double vector of length n.</li>
<li><strong>x0</strong> – double vector of length n. (optional) initial guess.</li>
<li><strong>tol</strong> – (optional) tolerance.</li>
<li><strong>itermax</strong> – (optional) maximum number of iterations.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>x</strong>: double vector of length n.</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2009 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="invsym">
<h2>invSym<a class="headerlink" href="#invsym" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.invSym">
<code class="descclassname">spams.</code><code class="descname">invSym</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.invSym" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the inverse of a symmetric matrix A</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> – double n x n matrix</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>B</strong>: double n x n matrix</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2009 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="normalize">
<h2>normalize<a class="headerlink" href="#normalize" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.normalize">
<code class="descclassname">spams.</code><code class="descname">normalize</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.normalize" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>rescale the columns of X so that they have</dt>
<dd>unit l2-norm.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> – double m x n matrix</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>Y</strong>: double m x n matrix</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2010 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sparseproject">
<h2>sparseProject<a class="headerlink" href="#sparseproject" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.sparseProject">
<code class="descclassname">spams.</code><code class="descname">sparseProject</code><span class="sig-paren">(</span><em>U</em>, <em>thrs=1.0</em>, <em>mode=1</em>, <em>lambda1=0.0</em>, <em>lambda2=0.0</em>, <em>lambda3=0.0</em>, <em>pos=0</em>, <em>numThreads=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.sparseProject" title="Permalink to this definition">¶</a></dt>
<dd><p>sparseProject solves various optimization 
problems, including projections on a few convex sets.</p>
<blockquote>
<div><p>It aims at addressing the following problems
for all columns u of U in parallel</p>
<blockquote>
<div><ol class="arabic">
<li><dl class="first docutils">
<dt>when mode=1 (projection on the l1-ball)</dt>
<dd><p class="first last">min_v ||u-v||_2^2  s.t.  ||v||_1 &lt;= thrs</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>when mode=2</dt>
<dd><p class="first last">min_v ||u-v||_2^2  s.t. ||v||_2^2 + lamuda1||v||_1 &lt;= thrs</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>when mode=3</dt>
<dd><p class="first last">min_v ||u-v||_2^2  s.t  ||v||_1 + 0.5lamuda1||v||_2^2 &lt;= thrs</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>when mode=4</dt>
<dd><p class="first last">min_v 0.5||u-v||_2^2 + lamuda1||v||_1  s.t  ||v||_2^2 &lt;= thrs</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>when mode=5</dt>
<dd><dl class="first last docutils">
<dt>min_v 0.5||u-v||_2^2 + lamuda1||v||_1 +lamuda2 FL(v) + … </dt>
<dd><p class="first last">0.5lamuda_3 ||v||_2^2</p>
</dd>
</dl>
</dd>
</dl>
<p>where FL denotes a “fused lasso” regularization term.</p>
</li>
<li><p class="first">when mode=6
min_v ||u-v||_2^2 s.t lamuda1||v||_1 +lamuda2 FL(v) + …</p>
<blockquote>
<div><p>0.5lamuda3||v||_2^2 &lt;= thrs</p>
</div></blockquote>
</li>
</ol>
<blockquote>
<div>When pos=true and mode &lt;= 4,
it solves the previous problems with positivity constraints</div></blockquote>
</div></blockquote>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> – double m x n matrix   (input signals)
m is the signal size
n is the number of signals to project</li>
<li><strong>thrs</strong> – (parameter)</li>
<li><strong>lambda1</strong> – (parameter)</li>
<li><strong>lambda2</strong> – (parameter)</li>
<li><strong>lambda3</strong> – (parameter)</li>
<li><strong>mode</strong> – (see above)</li>
<li><strong>pos</strong> – (optional, false by default)</li>
<li><strong>numThreads</strong> – (optional, number of threads for exploiting
multi-core / multi-cpus. By default, it takes the value -1,
which automatically selects all the available CPUs/cores).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>V</strong>: double m x n matrix (output matrix)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2009 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this function admits a few experimental usages, which have not
been extensively tested:
- single precision setting</p>
</div>
</dd></dl>

</div>
<div class="section" id="lasso">
<h2>lasso<a class="headerlink" href="#lasso" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.lasso">
<code class="descclassname">spams.</code><code class="descname">lasso</code><span class="sig-paren">(</span><em>X</em>, <em>D=None</em>, <em>Q=None</em>, <em>q=None</em>, <em>return_reg_path=False</em>, <em>L=-1</em>, <em>lambda1=None</em>, <em>lambda2=0.0</em>, <em>mode=2</em>, <em>pos=False</em>, <em>ols=False</em>, <em>numThreads=-1</em>, <em>max_length_path=-1</em>, <em>verbose=False</em>, <em>cholesky=False</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.lasso" title="Permalink to this definition">¶</a></dt>
<dd><p>lasso is an efficient implementation of the
homotopy-LARS algorithm for solving the Lasso.</p>
<blockquote>
<div><p>If the function is called this way spams.lasso(X,D = D, Q = None,…),
it aims at addressing the following problems
for all columns x of X, it computes one column alpha of A
that solves</p>
<blockquote>
<div><ol class="arabic simple">
<li>when mode=0</li>
</ol>
<blockquote>
<div>min_{alpha} ||x-Dalpha||_2^2 s.t. ||alpha||_1 &lt;= lambda1</div></blockquote>
<ol class="arabic simple" start="2">
<li>when mode=1</li>
</ol>
<blockquote>
<div>min_{alpha} ||alpha||_1 s.t. ||x-Dalpha||_2^2 &lt;= lambda1</div></blockquote>
<ol class="arabic simple" start="3">
<li>when mode=2</li>
</ol>
<blockquote>
<div>min_{alpha} 0.5||x-Dalpha||_2^2 + lambda1||alpha||_1 +0.5 lambda2||alpha||_2^2</div></blockquote>
</div></blockquote>
<p>If the function is called this way spams.lasso(X,D = None, Q = Q, q = q,…),
it solves the above optimisation problem, when Q=D’D and q=D’x.</p>
<p>Possibly, when pos=true, it solves the previous problems
with positivity constraints on the vectors alpha</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> – double m x n matrix   (input signals)
m is the signal size
n is the number of signals to decompose</li>
<li><strong>D</strong> – double m x p matrix   (dictionary)
p is the number of elements in the dictionary</li>
<li><strong>Q</strong> – p x p double matrix (Q = D’D)</li>
<li><strong>q</strong> – p x n double matrix (q = D’X)</li>
<li><strong>verbose</strong> – verbose mode</li>
<li><strong>return_reg_path</strong> – if true the function will return a tuple of matrices.</li>
<li><strong>lambda1</strong> – (parameter)</li>
<li><strong>lambda2</strong> – (optional parameter for solving the Elastic-Net)
for mode=0 and mode=1, it adds a ridge on the Gram Matrix</li>
<li><strong>L</strong> – (optional), maximum number of steps of the homotopy algorithm (can
be used as a stopping criterion)</li>
<li><strong>pos</strong> – (optional, adds non-negativity constraints on the
coefficients, false by default)</li>
<li><strong>mode</strong> – (see above, by default: 2)</li>
<li><strong>numThreads</strong> – (optional, number of threads for exploiting
multi-core / multi-cpus. By default, it takes the value -1,
which automatically selects all the available CPUs/cores).</li>
<li><strong>cholesky</strong> – (optional, default false),  choose between Cholesky 
implementation or one based on the matrix inversion Lemma</li>
<li><strong>ols</strong> – (optional, default false), perform an orthogonal projection
before returning the solution.</li>
<li><strong>max_length_path</strong> – (optional) maximum length of the path, by default 4*p</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>A</strong>: double sparse p x n matrix (output coefficients)</li>
<li><strong>path</strong>: optional,  returns the regularisation path for the first signal
A = spams.lasso(X,return_reg_path = False,…)
(A,path) = spams.lasso(X,return_reg_path = True,…)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2009 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this function admits a few experimental usages, which have not
been extensively tested:
- single precision setting (even though the output alpha is double 
precision)</p>
</div>
<dl class="docutils">
<dt><strong>Examples</strong>:</dt>
<dd><div class="first last highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">m</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span><span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span><span class="n">nD</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)))</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">X</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">X</span><span class="o">*</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)))</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">200</span><span class="p">)))</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">D</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">D</span><span class="o">*</span><span class="n">D</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),(</span><span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)))</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="n">spams</span><span class="o">.</span><span class="n">lasso</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">,</span><span class="n">return_reg_path</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">,</span><span class="n">lambda1</span> <span class="o">=</span> <span class="mf">0.15</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="lassomask">
<h2>lassoMask<a class="headerlink" href="#lassomask" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.lassoMask">
<code class="descclassname">spams.</code><code class="descname">lassoMask</code><span class="sig-paren">(</span><em>X</em>, <em>D</em>, <em>B</em>, <em>L=-1</em>, <em>lambda1=None</em>, <em>lambda2=0.0</em>, <em>mode=2</em>, <em>pos=False</em>, <em>numThreads=-1</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.lassoMask" title="Permalink to this definition">¶</a></dt>
<dd><p>lasso is a variant of lasso that handles
binary masks. It aims at addressing the following problems
for all columns x of X, and beta of B, it computes one column alpha of A
that solves</p>
<blockquote>
<div><ol class="arabic simple">
<li>when mode=0</li>
</ol>
<blockquote>
<div>min_{alpha} ||diag(beta)(x-Dalpha)||_2^2 s.t. ||alpha||_1 &lt;= lambda1</div></blockquote>
<ol class="arabic simple" start="2">
<li>when mode=1</li>
</ol>
<blockquote>
<div><dl class="docutils">
<dt>min_{alpha} ||alpha||_1 s.t. ||diag(beta)(x-Dalpha)||_2^2 </dt>
<dd>&lt;= lambda1*||beta||_0/m</dd>
</dl>
</div></blockquote>
<ol class="arabic simple" start="3">
<li>when mode=2</li>
</ol>
<blockquote>
<div><dl class="docutils">
<dt>min_{alpha} 0.5||diag(beta)(x-Dalpha)||_2^2 +</dt>
<dd>lambda1*(||beta||_0/m)*||alpha||_1 +
(lambda2/2)||alpha||_2^2</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>Possibly, when pos=true, it solves the previous problems
with positivity constraints on the vectors alpha</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> – double m x n matrix   (input signals)
m is the signal size
n is the number of signals to decompose</li>
<li><strong>D</strong> – double m x p matrix   (dictionary)
p is the number of elements in the dictionary</li>
<li><strong>B</strong> – boolean m x n matrix   (mask)
p is the number of elements in the dictionary</li>
<li><strong>verbose</strong> – verbose mode</li>
<li><strong>lambda1</strong> – (parameter)</li>
<li><strong>L</strong> – (optional, maximum number of elements of each 
decomposition)</li>
<li><strong>pos</strong> – (optional, adds positivity constraints on the
coefficients, false by default)</li>
<li><strong>mode</strong> – (see above, by default: 2)</li>
<li><strong>lambda2</strong> – (optional parameter for solving the Elastic-Net)
for mode=0 and mode=1, it adds a ridge on the Gram Matrix</li>
<li><strong>numThreads</strong> – (optional, number of threads for exploiting
multi-core / multi-cpus. By default, it takes the value -1,
which automatically selects all the available CPUs/cores).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>A</strong>: double sparse p x n matrix (output coefficients)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2010 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this function admits a few experimental usages, which have not
been extensively tested:
- single precision setting (even though the output alpha is double 
precision)</p>
</div>
</dd></dl>

</div>
<div class="section" id="lassoweighted">
<h2>lassoWeighted<a class="headerlink" href="#lassoweighted" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.lassoWeighted">
<code class="descclassname">spams.</code><code class="descname">lassoWeighted</code><span class="sig-paren">(</span><em>X</em>, <em>D</em>, <em>W</em>, <em>L=-1</em>, <em>lambda1=None</em>, <em>mode=2</em>, <em>pos=False</em>, <em>numThreads=-1</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.lassoWeighted" title="Permalink to this definition">¶</a></dt>
<dd><p>lassoWeighted is an efficient implementation of the
LARS algorithm for solving the weighted Lasso. It is optimized
for solving a large number of small or medium-sized 
decomposition problem (and not for a single large one).</p>
<blockquote>
<div><p>It first computes the Gram matrix D’D and then perform
a Cholesky-based OMP of the input signals in parallel.
For all columns x of X, and w of W, it computes one column alpha of A
which is the solution of</p>
<blockquote>
<div><ol class="arabic simple">
<li>when mode=0</li>
</ol>
<blockquote>
<div><dl class="docutils">
<dt>min_{alpha} ||x-Dalpha||_2^2   s.t.  </dt>
<dd>||diag(w)alpha||_1 &lt;= lambda1</dd>
</dl>
</div></blockquote>
<ol class="arabic simple" start="2">
<li>when mode=1</li>
</ol>
<blockquote>
<div><dl class="docutils">
<dt>min_{alpha} ||diag(w)alpha||_1  s.t.</dt>
<dd>||x-Dalpha||_2^2 &lt;= lambda1</dd>
</dl>
</div></blockquote>
<ol class="arabic simple" start="3">
<li>when mode=2</li>
</ol>
<blockquote>
<div><dl class="docutils">
<dt>min_{alpha} 0.5||x-Dalpha||_2^2  +  </dt>
<dd>lambda1||diag(w)alpha||_1</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>Possibly, when pos=true, it solves the previous problems
with positivity constraints on the vectors alpha</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> – double m x n matrix   (input signals)
m is the signal size
n is the number of signals to decompose</li>
<li><strong>D</strong> – double m x p matrix   (dictionary)
p is the number of elements in the dictionary</li>
<li><strong>W</strong> – double p x n matrix   (weights)</li>
<li><strong>verbose</strong> – verbose mode</li>
<li><strong>lambda1</strong> – (parameter)</li>
<li><strong>L</strong> – (optional, maximum number of elements of each 
decomposition)</li>
<li><strong>pos</strong> – (optional, adds positivity constraints on the
coefficients, false by default)</li>
<li><strong>mode</strong> – (see above, by default: 2)</li>
<li><strong>numThreads</strong> – (optional, number of threads for exploiting
multi-core / multi-cpus. By default, it takes the value -1,
which automatically selects all the available CPUs/cores).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>A</strong>: double sparse p x n matrix (output coefficients)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2009 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this function admits a few experimental usages, which have not
been extensively tested:
- single precision setting (even though the output alpha is double 
precision)</p>
</div>
</dd></dl>

</div>
<div class="section" id="omp">
<h2>omp<a class="headerlink" href="#omp" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.omp">
<code class="descclassname">spams.</code><code class="descname">omp</code><span class="sig-paren">(</span><em>X</em>, <em>D</em>, <em>L=None</em>, <em>eps=None</em>, <em>lambda1=None</em>, <em>return_reg_path=False</em>, <em>numThreads=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.omp" title="Permalink to this definition">¶</a></dt>
<dd><p>omp is an efficient implementation of the
Orthogonal Matching Pursuit algorithm. It is optimized
for solving a large number of small or medium-sized 
decomposition problem (and not for a single large one).</p>
<blockquote>
<div><p>It first computes the Gram matrix D’D and then perform
a Cholesky-based OMP of the input signals in parallel.
X=[x^1,…,x^n] is a matrix of signals, and it returns
a matrix A=[alpha^1,…,alpha^n] of coefficients.</p>
<dl class="docutils">
<dt>it addresses for all columns x of X, </dt>
<dd>min_{alpha} ||alpha||_0  s.t  ||x-Dalpha||_2^2 &lt;= eps
or
min_{alpha} ||x-Dalpha||_2^2  s.t. ||alpha||_0 &lt;= L
or
min_{alpha} 0.5||x-Dalpha||_2^2 + lambda1||alpha||_0</dd>
</dl>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> – double m x n matrix   (input signals)
m is the signal size
n is the number of signals to decompose</li>
<li><strong>D</strong> – double m x p matrix   (dictionary)
p is the number of elements in the dictionary
All the columns of D should have unit-norm !</li>
<li><strong>return_reg_path</strong> – if true the function will return a tuple of matrices.</li>
<li><strong>L</strong> – (optional, maximum number of elements in each decomposition, 
min(m,p) by default)</li>
<li><strong>eps</strong> – (optional, threshold on the squared l2-norm of the residual,
0 by default</li>
<li><strong>lambda1</strong> – (optional, penalty parameter, 0 by default</li>
<li><strong>numThreads</strong> – (optional, number of threads for exploiting
multi-core / multi-cpus. By default, it takes the value -1,
which automatically selects all the available CPUs/cores).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>A</strong>: double sparse p x n matrix (output coefficients)
path (optional): double dense p x L matrix (regularization path of the first signal)
A = spams.omp(X,D,L,eps,return_reg_path = False,…)
(A,path) = spams.omp(X,D,L,eps,return_reg_path = True,…)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2009 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this function admits a few experimental usages, which have not
been extensively tested:
- single precision setting (even though the output alpha is double 
precision)
- Passing an int32 vector of length n to L provides
a different parameter L for each input signal x_i
- Passing a double vector of length n to eps and or lambda1 
provides a different parameter eps (or lambda1) for each input signal x_i</p>
</div>
</dd></dl>

</div>
<div class="section" id="ompmask">
<h2>ompMask<a class="headerlink" href="#ompmask" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.ompMask">
<code class="descclassname">spams.</code><code class="descname">ompMask</code><span class="sig-paren">(</span><em>X</em>, <em>D</em>, <em>B</em>, <em>L=None</em>, <em>eps=None</em>, <em>lambda1=None</em>, <em>return_reg_path=False</em>, <em>numThreads=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.ompMask" title="Permalink to this definition">¶</a></dt>
<dd><p>ompMask is a variant of omp that allow using
a binary mask B</p>
<blockquote>
<div><dl class="docutils">
<dt>for all columns x of X, and columns beta of B, it computes a column </dt>
<dd><p class="first">alpha of A by addressing
min_{alpha} ||alpha||_0  s.t  ||diag(beta)*(x-Dalpha)||_2^2</p>
<blockquote>
<div>&lt;= eps*||beta||_0/m</div></blockquote>
<p class="last">or
min_{alpha} ||diag(beta)*(x-Dalpha)||_2^2  s.t. ||alpha||_0 &lt;= L
or
min_{alpha} 0.5||diag(beta)*(x-Dalpha)||_2^2  + lambda1||alpha||_0</p>
</dd>
</dl>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> – double m x n matrix   (input signals)
m is the signal size
n is the number of signals to decompose</li>
<li><strong>D</strong> – double m x p matrix   (dictionary)
p is the number of elements in the dictionary
All the columns of D should have unit-norm !</li>
<li><strong>B</strong> – boolean m x n matrix   (mask)
p is the number of elements in the dictionary</li>
<li><strong>return_reg_path</strong> – if true the function will return a tuple of matrices.</li>
<li><strong>L</strong> – (optional, maximum number of elements in each decomposition, 
min(m,p) by default)</li>
<li><strong>eps</strong> – (optional, threshold on the squared l2-norm of the residual,
0 by default</li>
<li><strong>lambda1</strong> – (optional, penalty parameter, 0 by default</li>
<li><strong>numThreads</strong> – (optional, number of threads for exploiting
multi-core / multi-cpus. By default, it takes the value -1,
which automatically selects all the available CPUs/cores).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>A</strong>: double sparse p x n matrix (output coefficients)
path (optional): double dense p x L matrix 
(regularization path of the first signal)
A = spams.ompMask(X,D,B,L,eps,return_reg_path = False,…)
(A,path) = spams.ompMask(X,D,B,L,eps,return_reg_path = True,…)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2010 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this function admits a few experimental usages, which have not
been extensively tested:
- single precision setting (even though the output alpha is double 
precision)
- Passing an int32 vector of length n to L provides
a different parameter L for each input signal x_i
- Passing a double vector of length n to eps and or lambda1 
provides a different parameter eps (or lambda1) for each input signal x_i</p>
</div>
</dd></dl>

</div>
<div class="section" id="cd">
<h2>cd<a class="headerlink" href="#cd" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.cd">
<code class="descclassname">spams.</code><code class="descname">cd</code><span class="sig-paren">(</span><em>X</em>, <em>D</em>, <em>A0</em>, <em>lambda1=None</em>, <em>mode=2</em>, <em>itermax=100</em>, <em>tol=0.001</em>, <em>numThreads=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.cd" title="Permalink to this definition">¶</a></dt>
<dd><p>cd addresses l1-decomposition problem with a 
coordinate descent type of approach.</p>
<blockquote>
<div><p>It is optimized for solving a large number of small or medium-sized 
decomposition problem (and not for a single large one).
It first computes the Gram matrix D’D.
This method is particularly well adapted when there is low 
correlation between the dictionary elements and when one can benefit 
from a warm restart.
It aims at addressing the two following problems
for all columns x of X, it computes a column alpha of A such that</p>
<blockquote>
<div><ol class="arabic simple" start="2">
<li>when mode=1</li>
</ol>
<blockquote>
<div>min_{alpha} ||alpha||_1 s.t. ||x-Dalpha||_2^2 &lt;= lambda1
For this constraint setting, the method solves a sequence of 
penalized problems (corresponding to mode=2) and looks
for the corresponding Lagrange multplier with a simple but
efficient heuristic.</div></blockquote>
<ol class="arabic simple" start="3">
<li>when mode=2</li>
</ol>
<blockquote>
<div>min_{alpha} 0.5||x-Dalpha||_2^2 + lambda1||alpha||_1</div></blockquote>
</div></blockquote>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> – double m x n matrix   (input signals)
m is the signal size
n is the number of signals to decompose</li>
<li><strong>D</strong> – double m x p matrix   (dictionary)
p is the number of elements in the dictionary
All the columns of D should have unit-norm !</li>
<li><strong>A0</strong> – double sparse p x n matrix   (initial guess)</li>
<li><strong>lambda1</strong> – (parameter)</li>
<li><strong>mode</strong> – (optional, see above, by default 2)</li>
<li><strong>itermax</strong> – (maximum number of iterations)</li>
<li><strong>tol</strong> – (tolerance parameter)</li>
<li><strong>numThreads</strong> – (optional, number of threads for exploiting
multi-core / multi-cpus. By default, it takes the value -1,
which automatically selects all the available CPUs/cores).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>A</strong>: double sparse p x n matrix (output coefficients)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2009 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this function admits a few experimental usages, which have not
been extensively tested:
- single precision setting (even though the output alpha 
is double precision)</p>
</div>
</dd></dl>

</div>
<div class="section" id="somp">
<h2>somp<a class="headerlink" href="#somp" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.somp">
<code class="descclassname">spams.</code><code class="descname">somp</code><span class="sig-paren">(</span><em>X</em>, <em>D</em>, <em>list_groups</em>, <em>L=None</em>, <em>eps=0.0</em>, <em>numThreads=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.somp" title="Permalink to this definition">¶</a></dt>
<dd><p>somp is an efficient implementation of a
Simultaneous Orthogonal Matching Pursuit algorithm. It is optimized
for solving a large number of small or medium-sized 
decomposition problem (and not for a single large one).</p>
<blockquote>
<div><p>It first computes the Gram matrix D’D and then perform
a Cholesky-based OMP of the input signals in parallel.
It aims at addressing the following NP-hard problem</p>
<p>X is a matrix structured in groups of signals, which we denote
by X=[X_1,…,X_n]</p>
<dl class="docutils">
<dt>for all matrices X_i of X, </dt>
<dd><p class="first">min_{A_i} ||A_i||_{0,infty}  s.t  ||X_i-D A_i||_2^2 &lt;= eps*n_i
where n_i is the number of columns of X_i</p>
<p>or</p>
<p class="last">min_{A_i} ||X_i-D A_i||_2^2  s.t. ||A_i||_{0,infty} &lt;= L</p>
</dd>
</dl>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> – double m x N matrix   (input signals)
m is the signal size
N is the total number of signals</li>
<li><strong>D</strong> – double m x p matrix   (dictionary)
p is the number of elements in the dictionary
All the columns of D should have unit-norm !</li>
<li><strong>list_groups</strong> – int32 vector containing the indices (starting at 0)
of the first elements of each groups.</li>
<li><strong>L</strong> – (maximum number of elements in each decomposition)</li>
<li><strong>eps</strong> – (threshold on the squared l2-norm of the residual</li>
<li><strong>numThreads</strong> – (optional, number of threads for exploiting
multi-core / multi-cpus. By default, it takes the value -1,
which automatically selects all the available CPUs/cores).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>alpha</strong>: double sparse p x N matrix (output coefficients)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2010 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this function admits a few experimental usages, which have not
been extensively tested:
- single precision setting (even though the output alpha is double 
precision)</p>
</div>
</dd></dl>

</div>
<div class="section" id="l1l2bcd">
<h2>l1L2BCD<a class="headerlink" href="#l1l2bcd" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.l1L2BCD">
<code class="descclassname">spams.</code><code class="descname">l1L2BCD</code><span class="sig-paren">(</span><em>X</em>, <em>D</em>, <em>alpha0</em>, <em>list_groups</em>, <em>lambda1=None</em>, <em>mode=2</em>, <em>itermax=100</em>, <em>tol=0.001</em>, <em>numThreads=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.l1L2BCD" title="Permalink to this definition">¶</a></dt>
<dd><p>l1L2BCD is a solver for a 
Simultaneous signal decomposition formulation based on block 
coordinate descent.</p>
<blockquote>
<div><p>X is a matrix structured in groups of signals, which we denote
by X=[X_1,…,X_n]</p>
<dl class="docutils">
<dt>if mode=2, it solves</dt>
<dd>for all matrices X_i of X, 
min_{A_i} 0.5||X_i-D A_i||_2^2 + lambda1/sqrt(n_i)||A_i||_{1,2}  
where n_i is the number of columns of X_i</dd>
<dt>if mode=1, it solves</dt>
<dd>min_{A_i} ||A_i||_{1,2} s.t. ||X_i-D A_i||_2^2  &lt;= n_i lambda1</dd>
</dl>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> – double m x N matrix   (input signals)
m is the signal size
N is the total number of signals</li>
<li><strong>D</strong> – double m x p matrix   (dictionary)
p is the number of elements in the dictionary</li>
<li><strong>alpha0</strong> – double dense p x N matrix (initial solution)</li>
<li><strong>list_groups</strong> – int32 vector containing the indices (starting at 0)
of the first elements of each groups.</li>
<li><strong>lambda1</strong> – (regularization parameter)</li>
<li><strong>mode</strong> – (see above, by default 2)</li>
<li><strong>itermax</strong> – (maximum number of iterations, by default 100)</li>
<li><strong>tol</strong> – (tolerance parameter, by default 0.001)</li>
<li><strong>numThreads</strong> – (optional, number of threads for exploiting
multi-core / multi-cpus. By default, it takes the value -1,
which automatically selects all the available CPUs/cores).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>alpha</strong>: double sparse p x N matrix (output coefficients)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2010 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this function admits a few experimental usages, which have not
been extensively tested:
- single precision setting (even though the output alpha is double 
precision)</p>
</div>
</dd></dl>

</div>
<div class="section" id="fistaflat">
<h2>fistaFlat<a class="headerlink" href="#fistaflat" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.fistaFlat">
<code class="descclassname">spams.</code><code class="descname">fistaFlat</code><span class="sig-paren">(</span><em>Y</em>, <em>X</em>, <em>W0</em>, <em>return_optim_info=False</em>, <em>numThreads=-1</em>, <em>max_it=1000</em>, <em>L0=1.0</em>, <em>fixed_step=False</em>, <em>gamma=1.5</em>, <em>lambda1=1.0</em>, <em>delta=1.0</em>, <em>lambda2=0.0</em>, <em>lambda3=0.0</em>, <em>a=1.0</em>, <em>b=0.0</em>, <em>c=1.0</em>, <em>tol=1e-06</em>, <em>it0=100</em>, <em>max_iter_backtracking=1000</em>, <em>compute_gram=False</em>, <em>lin_admm=False</em>, <em>admm=False</em>, <em>intercept=False</em>, <em>resetflow=False</em>, <em>regul=''</em>, <em>loss=''</em>, <em>verbose=False</em>, <em>pos=False</em>, <em>clever=False</em>, <em>log=False</em>, <em>ista=False</em>, <em>subgrad=False</em>, <em>logName=''</em>, <em>is_inner_weights=False</em>, <em>inner_weights=None</em>, <em>size_group=1</em>, <em>groups=None</em>, <em>sqrt_step=True</em>, <em>transpose=False</em>, <em>linesearch_mode=0</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.fistaFlat" title="Permalink to this definition">¶</a></dt>
<dd><p>fistaFlat solves sparse regularized problems.</p>
<blockquote>
<div><p>X is a design matrix of size m x p
X=[x^1,…,x^n]’, where the x_i’s are the rows of X
Y=[y^1,…,y^n] is a matrix of size m x n
It implements the algorithms FISTA, ISTA and subgradient descent.</p>
<blockquote>
<div><ul>
<li><p class="first">if loss=’square’ and regul is a regularization function for vectors,
the entries of Y are real-valued,  W = [w^1,…,w^n] is a matrix of size p x n
For all column y of Y, it computes a column w of W such that</p>
<blockquote>
<div><p>w = argmin 0.5||y- X w||_2^2 + lambda1 psi(w)</p>
</div></blockquote>
</li>
<li><p class="first">if loss=’square’ and regul is a regularization function for matrices
the entries of Y are real-valued,  W is a matrix of size p x n. 
It computes the matrix W such that</p>
<blockquote>
<div><p>W = argmin 0.5||Y- X W||_F^2 + lambda1 psi(W)</p>
</div></blockquote>
</li>
<li><p class="first">loss=’square-missing’ same as loss=’square’, but handles missing data
represented by NaN (not a number) in the matrix Y</p>
</li>
<li><p class="first">if loss=’logistic’ and regul is a regularization function for vectors,
the entries of Y are either -1 or +1, W = [w^1,…,w^n] is a matrix of size p x n
For all column y of Y, it computes a column w of W such that</p>
<blockquote>
<div><p>w = argmin (1/m)sum_{j=1}^m log(1+e^(-y_j x^j’ w)) + lambda1 psi(w),</p>
</div></blockquote>
<p>where x^j is the j-th row of X.</p>
</li>
<li><p class="first">if loss=’logistic’ and regul is a regularization function for matrices
the entries of Y are either -1 or +1, W is a matrix of size p x n</p>
<blockquote>
<div><p>W = argmin sum_{i=1}^n(1/m)sum_{j=1}^m log(1+e^(-y^i_j x^j’ w^i)) + lambda1 psi(W)</p>
</div></blockquote>
</li>
<li><p class="first">if loss=’multi-logistic’ and regul is a regularization function for vectors,
the entries of Y are in {0,1,…,N} where N is the total number of classes
W = [W^1,…,W^n] is a matrix of size p x Nn, each submatrix W^i is of size p x N
for all submatrix WW of W, and column y of Y, it computes</p>
<blockquote>
<div><p>WW = argmin (1/m)sum_{j=1}^m log(sum_{j=1}^r e^(x^j’(ww^j-ww^{y_j}))) + lambda1 sum_{j=1}^N psi(ww^j),</p>
</div></blockquote>
<p>where ww^j is the j-th column of WW.</p>
</li>
<li><p class="first">if loss=’multi-logistic’ and regul is a regularization function for matrices,
the entries of Y are in {0,1,…,N} where N is the total number of classes
W is a matrix of size p x N, it computes</p>
<blockquote>
<div><p>W = argmin (1/m)sum_{j=1}^m log(sum_{j=1}^r e^(x^j’(w^j-w^{y_j}))) + lambda1 psi(W)</p>
</div></blockquote>
<p>where ww^j is the j-th column of WW.</p>
</li>
<li><dl class="first docutils">
<dt>loss=’cur’ useful to perform sparse CUR matrix decompositions, </dt>
<dd><p class="first last">W = argmin 0.5||Y-X*W*X||_F^2 + lambda1 psi(W)</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>The function psi are those used by proximalFlat (see documentation)</p>
<p>This function can also handle intercepts (last row of W is not regularized),
and/or non-negativity constraints on W, and sparse matrices for X</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Y</strong> – double dense m x n matrix</li>
<li><strong>X</strong> – double dense or sparse m x p matrix</li>
<li><strong>W0</strong> – double dense p x n matrix or p x Nn matrix (for multi-logistic loss)
initial guess</li>
<li><strong>return_optim_info</strong> – if true the function will return a tuple of matrices.</li>
<li><strong>loss</strong> – (choice of loss, see above)</li>
<li><strong>regul</strong> – (choice of regularization, see function proximalFlat)</li>
<li><strong>lambda1</strong> – (regularization parameter)</li>
<li><strong>lambda2</strong> – (optional, regularization parameter, 0 by default)</li>
<li><strong>lambda3</strong> – (optional, regularization parameter, 0 by default)</li>
<li><strong>verbose</strong> – (optional, verbosity level, false by default)</li>
<li><strong>pos</strong> – (optional, adds positivity constraints on the
coefficients, false by default)</li>
<li><strong>transpose</strong> – (optional, transpose the matrix in the regularization function)</li>
<li><strong>size_group</strong> – (optional, for regularization functions assuming a group
structure)</li>
<li><strong>groups</strong> – (int32, optional, for regularization functions assuming a group
structure, see proximalFlat)</li>
<li><strong>numThreads</strong> – (optional, number of threads for exploiting
multi-core / multi-cpus. By default, it takes the value -1,
which automatically selects all the available CPUs/cores).</li>
<li><strong>max_it</strong> – (optional, maximum number of iterations, 100 by default)</li>
<li><strong>it0</strong> – (optional, frequency for computing duality gap, every 10 iterations by default)</li>
<li><strong>tol</strong> – (optional, tolerance for stopping criteration, which is a relative duality gap
if it is available, or a relative change of parameters).</li>
<li><strong>gamma</strong> – (optional, multiplier for increasing the parameter L in fista, 1.5 by default)</li>
<li><strong>L0</strong> – (optional, initial parameter L in fista, 0.1 by default, should be small enough)</li>
<li><strong>fixed_step</strong> – (deactive the line search for L in fista and use L0 instead)</li>
<li><strong>linesearch_mode</strong> – (line-search scheme when ista=true:</li>
<li><strong>0</strong> – default, monotonic backtracking scheme</li>
<li><strong>1</strong> – monotonic backtracking scheme, with restart at each iteration</li>
<li><strong>2</strong> – Barzilai-Borwein step sizes (similar to SparSA by Wright et al.)</li>
<li><strong>3</strong> – non-monotonic backtracking</li>
<li><strong>compute_gram</strong> – (optional, pre-compute X^TX, false by default).</li>
<li><strong>intercept</strong> – (optional, do not regularize last row of W, false by default).</li>
<li><strong>ista</strong> – (optional, use ista instead of fista, false by default).</li>
<li><strong>subgrad</strong> – (optional, if not ista, use subradient descent instead of fista, false by default).</li>
<li><strong>a</strong> – </li>
<li><strong>b</strong> – <p>(optional, if subgrad, the gradient step is a/(t+b)
also similar options as proximalFlat</p>
<p>the function also implements the ADMM algorithm via an option admm=true. It is not documented
and you need to look at the source code to use it.</p>
</li>
<li><strong>delta</strong> – undocumented; modify at your own risks!</li>
<li><strong>c</strong> – undocumented; modify at your own risks!</li>
<li><strong>max_iter_backtracking</strong> – undocumented; modify at your own risks!</li>
<li><strong>lin_admm</strong> – undocumented; modify at your own risks!</li>
<li><strong>admm</strong> – undocumented; modify at your own risks!</li>
<li><strong>resetflow</strong> – undocumented; modify at your own risks!</li>
<li><strong>clever</strong> – undocumented; modify at your own risks!</li>
<li><strong>log</strong> – undocumented; modify at your own risks!</li>
<li><strong>logName</strong> – undocumented; modify at your own risks!</li>
<li><strong>is_inner_weights</strong> – undocumented; modify at your own risks!</li>
<li><strong>inner_weights</strong> – undocumented; modify at your own risks!</li>
<li><strong>sqrt_step</strong> – undocumented; modify at your own risks!</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>W</strong>: double dense p x n matrix or p x Nn matrix (for multi-logistic loss)</li>
<li><strong>optim</strong>: optional, double dense 4 x n matrix.
first row: values of the objective functions.
third row: values of the relative duality gap (if available)
fourth row: number of iterations</li>
<li><strong>optim_info</strong>: vector of size 4, containing information of the optimization.
W = spams.fistaFlat(Y,X,W0,return_optim_info = False,…)
(W,optim_info) = spams.fistaFlat(Y,X,W0,return_optim_info = True,…)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2010 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Valid values for the regularization parameter (regul) are:
“l0”, “l1”, “l2”, “linf”, “l2-not-squared”, “elastic-net”, “fused-lasso”,
“group-lasso-l2”, “group-lasso-linf”, “sparse-group-lasso-l2”,
“sparse-group-lasso-linf”, “l1l2”, “l1linf”, “l1l2+l1”, “l1linf+l1”,
“tree-l0”, “tree-l2”, “tree-linf”, “graph”, “graph-ridge”, “graph-l2”,
“multi-task-tree”, “multi-task-graph”, “l1linf-row-column”, “trace-norm”,
“trace-norm-vec”, “rank”, “rank-vec”, “none”</p>
</div>
</dd></dl>

</div>
<div class="section" id="fistatree">
<h2>fistaTree<a class="headerlink" href="#fistatree" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.fistaTree">
<code class="descclassname">spams.</code><code class="descname">fistaTree</code><span class="sig-paren">(</span><em>Y</em>, <em>X</em>, <em>W0</em>, <em>tree</em>, <em>return_optim_info=False</em>, <em>numThreads=-1</em>, <em>max_it=1000</em>, <em>L0=1.0</em>, <em>fixed_step=False</em>, <em>gamma=1.5</em>, <em>lambda1=1.0</em>, <em>delta=1.0</em>, <em>lambda2=0.0</em>, <em>lambda3=0.0</em>, <em>a=1.0</em>, <em>b=0.0</em>, <em>c=1.0</em>, <em>tol=1e-06</em>, <em>it0=100</em>, <em>max_iter_backtracking=1000</em>, <em>compute_gram=False</em>, <em>lin_admm=False</em>, <em>admm=False</em>, <em>intercept=False</em>, <em>resetflow=False</em>, <em>regul=''</em>, <em>loss=''</em>, <em>verbose=False</em>, <em>pos=False</em>, <em>clever=False</em>, <em>log=False</em>, <em>ista=False</em>, <em>subgrad=False</em>, <em>logName=''</em>, <em>is_inner_weights=False</em>, <em>inner_weights=None</em>, <em>size_group=1</em>, <em>sqrt_step=True</em>, <em>transpose=False</em>, <em>linesearch_mode=0</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.fistaTree" title="Permalink to this definition">¶</a></dt>
<dd><p>fistaTree solves sparse regularized problems.</p>
<blockquote>
<div><p>X is a design matrix of size m x p
X=[x^1,…,x^n]’, where the x_i’s are the rows of X
Y=[y^1,…,y^n] is a matrix of size m x n
It implements the algorithms FISTA, ISTA and subgradient descent for solving</p>
<blockquote>
<div>min_W  loss(W) + lambda1 psi(W)</div></blockquote>
<p>The function psi are those used by proximalTree (see documentation)
for the loss functions, see the documentation of fistaFlat</p>
<p>This function can also handle intercepts (last row of W is not regularized),
and/or non-negativity constraints on W and sparse matrices X</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Y</strong> – double dense m x n matrix</li>
<li><strong>X</strong> – double dense or sparse m x p matrix</li>
<li><strong>W0</strong> – double dense p x n matrix or p x Nn matrix (for multi-logistic loss)
initial guess</li>
<li><strong>tree</strong> – named list (see documentation of proximalTree)</li>
<li><strong>return_optim_info</strong> – if true the function will return a tuple of matrices.</li>
<li><strong>loss</strong> – (choice of loss, see above)</li>
<li><strong>regul</strong> – (choice of regularization, see function proximalFlat)</li>
<li><strong>lambda1</strong> – (regularization parameter)</li>
<li><strong>lambda2</strong> – (optional, regularization parameter, 0 by default)</li>
<li><strong>lambda3</strong> – (optional, regularization parameter, 0 by default)</li>
<li><strong>verbose</strong> – (optional, verbosity level, false by default)</li>
<li><strong>pos</strong> – (optional, adds positivity constraints on the
coefficients, false by default)</li>
<li><strong>transpose</strong> – (optional, transpose the matrix in the regularization function)</li>
<li><strong>size_group</strong> – (optional, for regularization functions assuming a group
structure)</li>
<li><strong>numThreads</strong> – (optional, number of threads for exploiting
multi-core / multi-cpus. By default, it takes the value -1,
which automatically selects all the available CPUs/cores).</li>
<li><strong>max_it</strong> – (optional, maximum number of iterations, 100 by default)</li>
<li><strong>it0</strong> – (optional, frequency for computing duality gap, every 10 iterations by default)</li>
<li><strong>tol</strong> – (optional, tolerance for stopping criteration, which is a relative duality gap
if it is available, or a relative change of parameters).</li>
<li><strong>gamma</strong> – (optional, multiplier for increasing the parameter L in fista, 1.5 by default)</li>
<li><strong>L0</strong> – (optional, initial parameter L in fista, 0.1 by default, should be small enough)</li>
<li><strong>fixed_step</strong> – (deactive the line search for L in fista and use L0 instead)</li>
<li><strong>compute_gram</strong> – (optional, pre-compute X^TX, false by default).</li>
<li><strong>intercept</strong> – (optional, do not regularize last row of W, false by default).</li>
<li><strong>ista</strong> – (optional, use ista instead of fista, false by default).</li>
<li><strong>subgrad</strong> – (optional, if not ista, use subradient descent instead of fista, false by default).</li>
<li><strong>a</strong> – </li>
<li><strong>b</strong> – <p>(optional, if subgrad, the gradient step is a/(t+b)
also similar options as proximalTree</p>
<p>the function also implements the ADMM algorithm via an option admm=true. It is not documented
and you need to look at the source code to use it.</p>
</li>
<li><strong>delta</strong> – undocumented; modify at your own risks!</li>
<li><strong>c</strong> – undocumented; modify at your own risks!</li>
<li><strong>max_iter_backtracking</strong> – undocumented; modify at your own risks!</li>
<li><strong>lin_admm</strong> – undocumented; modify at your own risks!</li>
<li><strong>admm</strong> – undocumented; modify at your own risks!</li>
<li><strong>resetflow</strong> – undocumented; modify at your own risks!</li>
<li><strong>clever</strong> – undocumented; modify at your own risks!</li>
<li><strong>log</strong> – undocumented; modify at your own risks!</li>
<li><strong>logName</strong> – undocumented; modify at your own risks!</li>
<li><strong>is_inner_weights</strong> – undocumented; modify at your own risks!</li>
<li><strong>inner_weights</strong> – undocumented; modify at your own risks!</li>
<li><strong>sqrt_step</strong> – undocumented; modify at your own risks!</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>W</strong>: double dense p x n matrix or p x Nn matrix (for multi-logistic loss)</li>
<li><strong>optim</strong>: optional, double dense 4 x n matrix.
first row: values of the objective functions.
third row: values of the relative duality gap (if available)
fourth row: number of iterations</li>
<li><strong>optim_info</strong>: vector of size 4, containing information of the optimization.
W = spams.fistaTree(Y,X,W0,tree,return_optim_info = False,…)
(W,optim_info) = spams.fistaTree(Y,X,W0,tree,return_optim_info = True,…)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2010 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Valid values for the regularization parameter (regul) are:
“l0”, “l1”, “l2”, “linf”, “l2-not-squared”, “elastic-net”, “fused-lasso”,
“group-lasso-l2”, “group-lasso-linf”, “sparse-group-lasso-l2”,
“sparse-group-lasso-linf”, “l1l2”, “l1linf”, “l1l2+l1”, “l1linf+l1”,
“tree-l0”, “tree-l2”, “tree-linf”, “graph”, “graph-ridge”, “graph-l2”,
“multi-task-tree”, “multi-task-graph”, “l1linf-row-column”, “trace-norm”,
“trace-norm-vec”, “rank”, “rank-vec”, “none”</p>
</div>
</dd></dl>

</div>
<div class="section" id="fistagraph">
<h2>fistaGraph<a class="headerlink" href="#fistagraph" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.fistaGraph">
<code class="descclassname">spams.</code><code class="descname">fistaGraph</code><span class="sig-paren">(</span><em>Y</em>, <em>X</em>, <em>W0</em>, <em>graph</em>, <em>return_optim_info=False</em>, <em>numThreads=-1</em>, <em>max_it=1000</em>, <em>L0=1.0</em>, <em>fixed_step=False</em>, <em>gamma=1.5</em>, <em>lambda1=1.0</em>, <em>delta=1.0</em>, <em>lambda2=0.0</em>, <em>lambda3=0.0</em>, <em>a=1.0</em>, <em>b=0.0</em>, <em>c=1.0</em>, <em>tol=1e-06</em>, <em>it0=100</em>, <em>max_iter_backtracking=1000</em>, <em>compute_gram=False</em>, <em>lin_admm=False</em>, <em>admm=False</em>, <em>intercept=False</em>, <em>resetflow=False</em>, <em>regul=''</em>, <em>loss=''</em>, <em>verbose=False</em>, <em>pos=False</em>, <em>clever=False</em>, <em>log=False</em>, <em>ista=False</em>, <em>subgrad=False</em>, <em>logName=''</em>, <em>is_inner_weights=False</em>, <em>inner_weights=None</em>, <em>size_group=1</em>, <em>sqrt_step=True</em>, <em>transpose=False</em>, <em>linesearch_mode=0</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.fistaGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>fistaGraph solves sparse regularized problems.</p>
<blockquote>
<div><p>X is a design matrix of size m x p
X=[x^1,…,x^n]’, where the x_i’s are the rows of X
Y=[y^1,…,y^n] is a matrix of size m x n
It implements the algorithms FISTA, ISTA and subgradient descent.</p>
<p>It implements the algorithms FISTA, ISTA and subgradient descent for solving</p>
<blockquote>
<div>min_W  loss(W) + lambda1 psi(W)</div></blockquote>
<p>The function psi are those used by proximalGraph (see documentation)
for the loss functions, see the documentation of fistaFlat</p>
<p>This function can also handle intercepts (last row of W is not regularized),
and/or non-negativity constraints on W.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Y</strong> – double dense m x n matrix</li>
<li><strong>X</strong> – double dense or sparse m x p matrix</li>
<li><strong>W0</strong> – double dense p x n matrix or p x Nn matrix (for multi-logistic loss)
initial guess</li>
<li><strong>graph</strong> – struct (see documentation of proximalGraph)</li>
<li><strong>return_optim_info</strong> – if true the function will return a tuple of matrices.</li>
<li><strong>loss</strong> – (choice of loss, see above)</li>
<li><strong>regul</strong> – (choice of regularization, see function proximalFlat)</li>
<li><strong>lambda1</strong> – (regularization parameter)</li>
<li><strong>lambda2</strong> – (optional, regularization parameter, 0 by default)</li>
<li><strong>lambda3</strong> – (optional, regularization parameter, 0 by default)</li>
<li><strong>verbose</strong> – (optional, verbosity level, false by default)</li>
<li><strong>pos</strong> – (optional, adds positivity constraints on the
coefficients, false by default)</li>
<li><strong>numThreads</strong> – (optional, number of threads for exploiting
multi-core / multi-cpus. By default, it takes the value -1,
which automatically selects all the available CPUs/cores).</li>
<li><strong>max_it</strong> – (optional, maximum number of iterations, 100 by default)</li>
<li><strong>it0</strong> – (optional, frequency for computing duality gap, every 10 iterations by default)</li>
<li><strong>tol</strong> – (optional, tolerance for stopping criteration, which is a relative duality gap
if it is available, or a relative change of parameters).</li>
<li><strong>gamma</strong> – (optional, multiplier for increasing the parameter L in fista, 1.5 by default)</li>
<li><strong>L0</strong> – (optional, initial parameter L in fista, 0.1 by default, should be small enough)</li>
<li><strong>fixed_step</strong> – (deactive the line search for L in fista and use L0 instead)</li>
<li><strong>compute_gram</strong> – (optional, pre-compute X^TX, false by default).</li>
<li><strong>intercept</strong> – (optional, do not regularize last row of W, false by default).</li>
<li><strong>ista</strong> – (optional, use ista instead of fista, false by default).</li>
<li><strong>subgrad</strong> – (optional, if not ista, use subradient descent instead of fista, false by default).</li>
<li><strong>a</strong> – </li>
<li><strong>b</strong> – <p>(optional, if subgrad, the gradient step is a/(t+b)
also similar options as proximalTree</p>
<p>the function also implements the ADMM algorithm via an option admm=true. It is not documented
and you need to look at the source code to use it.</p>
</li>
<li><strong>delta</strong> – undocumented; modify at your own risks!</li>
<li><strong>c</strong> – undocumented; modify at your own risks!</li>
<li><strong>max_iter_backtracking</strong> – undocumented; modify at your own risks!</li>
<li><strong>lin_admm</strong> – undocumented; modify at your own risks!</li>
<li><strong>admm</strong> – undocumented; modify at your own risks!</li>
<li><strong>resetflow</strong> – undocumented; modify at your own risks!</li>
<li><strong>clever</strong> – undocumented; modify at your own risks!</li>
<li><strong>log</strong> – undocumented; modify at your own risks!</li>
<li><strong>logName</strong> – undocumented; modify at your own risks!</li>
<li><strong>is_inner_weights</strong> – undocumented; modify at your own risks!</li>
<li><strong>inner_weights</strong> – undocumented; modify at your own risks!</li>
<li><strong>sqrt_step</strong> – undocumented; modify at your own risks!</li>
<li><strong>size_group</strong> – undocumented; modify at your own risks!</li>
<li><strong>transpose</strong> – undocumented; modify at your own risks!</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>W</strong>: double dense p x n matrix or p x Nn matrix (for multi-logistic loss)</li>
<li><strong>optim</strong>: optional, double dense 4 x n matrix.
first row: values of the objective functions.
third row: values of the relative duality gap (if available)
fourth row: number of iterations</li>
<li><strong>optim_info</strong>: vector of size 4, containing information of the optimization.
W = spams.fistaGraph(Y,X,W0,graph,return_optim_info = False,…)
(W,optim_info) = spams.fistaGraph(Y,X,W0,graph,return_optim_info = True,…)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2010 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Valid values for the regularization parameter (regul) are:
“l0”, “l1”, “l2”, “linf”, “l2-not-squared”, “elastic-net”, “fused-lasso”,
“group-lasso-l2”, “group-lasso-linf”, “sparse-group-lasso-l2”,
“sparse-group-lasso-linf”, “l1l2”, “l1linf”, “l1l2+l1”, “l1linf+l1”,
“tree-l0”, “tree-l2”, “tree-linf”, “graph”, “graph-ridge”, “graph-l2”,
“multi-task-tree”, “multi-task-graph”, “l1linf-row-column”, “trace-norm”,
“trace-norm-vec”, “rank”, “rank-vec”, “none”</p>
</div>
</dd></dl>

</div>
<div class="section" id="proximalflat">
<h2>proximalFlat<a class="headerlink" href="#proximalflat" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.proximalFlat">
<code class="descclassname">spams.</code><code class="descname">proximalFlat</code><span class="sig-paren">(</span><em>U</em>, <em>return_val_loss=False</em>, <em>numThreads=-1</em>, <em>lambda1=1.0</em>, <em>lambda2=0.0</em>, <em>lambda3=0.0</em>, <em>intercept=False</em>, <em>resetflow=False</em>, <em>regul=''</em>, <em>verbose=False</em>, <em>pos=False</em>, <em>clever=True</em>, <em>size_group=1</em>, <em>groups=None</em>, <em>transpose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.proximalFlat" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>proximalFlat computes proximal operators. Depending</dt>
<dd><p class="first">on the value of regul, it computes</p>
<p>Given an input matrix U=[u^1,ldots,u^n], it computes a matrix 
V=[v^1,ldots,v^n] such that
if one chooses a regularization functions on vectors, it computes
for each column u of U, a column v of V solving
if regul=’l0’</p>
<blockquote>
<div>argmin 0.5||u-v||_2^2 + lambda1||v||_0</div></blockquote>
<dl class="docutils">
<dt>if regul=’l1’</dt>
<dd>argmin 0.5||u-v||_2^2 + lambda1||v||_1</dd>
<dt>if regul=’l2’</dt>
<dd>argmin 0.5||u-v||_2^2 + 0.5lambda1||v||_2^2</dd>
<dt>if regul=’elastic-net’</dt>
<dd>argmin 0.5||u-v||_2^2 + lambda1||v||_1 + lambda1_2||v||_2^2</dd>
<dt>if regul=’fused-lasso’</dt>
<dd><dl class="first last docutils">
<dt>argmin 0.5||u-v||_2^2 + lambda1 FL(v) + …</dt>
<dd>…  lambda1_2||v||_1 + lambda1_3||v||_2^2</dd>
</dl>
</dd>
<dt>if regul=’linf’</dt>
<dd>argmin 0.5||u-v||_2^2 + lambda1||v||_inf</dd>
<dt>if regul=’l1-constraint’</dt>
<dd>argmin 0.5||u-v||_2^2 s.t. ||v||_1 &lt;= lambda1</dd>
<dt>if regul=’l2-not-squared’</dt>
<dd>argmin 0.5||u-v||_2^2 + lambda1||v||_2</dd>
<dt>if regul=’group-lasso-l2’  </dt>
<dd>argmin 0.5||u-v||_2^2 + lambda1 sum_g ||v_g||_2 
where the groups are either defined by groups or by size_group,</dd>
<dt>if regul=’group-lasso-linf’</dt>
<dd>argmin 0.5||u-v||_2^2 + lambda1 sum_g ||v_g||_inf</dd>
<dt>if regul=’sparse-group-lasso-l2’  </dt>
<dd>argmin 0.5||u-v||_2^2 + lambda1 sum_g ||v_g||_2 + lambda1_2 ||v||_1
where the groups are either defined by groups or by size_group,</dd>
<dt>if regul=’sparse-group-lasso-linf’</dt>
<dd>argmin 0.5||u-v||_2^2 + lambda1 sum_g ||v_g||_inf + lambda1_2 ||v||_1</dd>
<dt>if regul=’trace-norm-vec’ </dt>
<dd><blockquote class="first">
<div>argmin 0.5||u-v||_2^2 + lambda1 ||mat(v)||_*</div></blockquote>
<p class="last">where mat(v) has size_group rows</p>
</dd>
</dl>
<p>if one chooses a regularization function on matrices
if regul=’l1l2’,  V=</p>
<blockquote>
<div>argmin 0.5||U-V||_F^2 + lambda1||V||_{1/2}</div></blockquote>
<dl class="docutils">
<dt>if regul=’l1linf’,  V= </dt>
<dd>argmin 0.5||U-V||_F^2 + lambda1||V||_{1/inf}</dd>
<dt>if regul=’l1l2+l1’,  V= </dt>
<dd>argmin 0.5||U-V||_F^2 + lambda1||V||_{1/2} + lambda1_2||V||_{1/1}</dd>
<dt>if regul=’l1linf+l1’,  V= </dt>
<dd>argmin 0.5||U-V||_F^2 + lambda1||V||_{1/inf} + lambda1_2||V||_{1/1}</dd>
<dt>if regul=’l1linf+row-column’,  V= </dt>
<dd>argmin 0.5||U-V||_F^2 + lambda1||V||_{1/inf} + lambda1_2||V’||_{1/inf}</dd>
<dt>if regul=’trace-norm’,  V= </dt>
<dd>argmin 0.5||U-V||_F^2 + lambda1||V||_*</dd>
<dt>if regul=’rank’,  V= </dt>
<dd>argmin 0.5||U-V||_F^2 + lambda1 rank(V)</dd>
<dt>if regul=’none’,  V= </dt>
<dd>argmin 0.5||U-V||_F^2</dd>
</dl>
<p class="last">for all these regularizations, it is possible to enforce non-negativity constraints
with the option pos, and to prevent the last row of U to be regularized, with
the option intercept</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> – double m x n matrix   (input signals)
m is the signal size</li>
<li><strong>return_val_loss</strong> – if true the function will return a tuple of matrices.</li>
<li><strong>lambda1</strong> – (regularization parameter)</li>
<li><strong>regul</strong> – (choice of regularization, see above)</li>
<li><strong>lambda2</strong> – (optional, regularization parameter)</li>
<li><strong>lambda3</strong> – (optional, regularization parameter)</li>
<li><strong>verbose</strong> – (optional, verbosity level, false by default)</li>
<li><strong>intercept</strong> – (optional, last row of U is not regularized,
false by default)</li>
<li><strong>transpose</strong> – (optional, transpose the matrix in the regularization function)</li>
<li><strong>size_group</strong> – (optional, for regularization functions assuming a group
structure). It is a scalar. When groups is not specified, it assumes
that the groups are the sets of consecutive elements of size size_group</li>
<li><strong>groups</strong> – (int32, optional, for regularization functions assuming a group
structure. It is an int32 vector of size m containing the group indices of the
variables (first group is 1).</li>
<li><strong>pos</strong> – (optional, adds positivity constraints on the
coefficients, false by default)</li>
<li><strong>numThreads</strong> – (optional, number of threads for exploiting
multi-core / multi-cpus. By default, it takes the value -1,
which automatically selects all the available CPUs/cores).</li>
<li><strong>resetflow</strong> – undocumented; modify at your own risks!</li>
<li><strong>clever</strong> – undocumented; modify at your own risks!</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>V</strong>: double m x n matrix (output coefficients)</li>
<li><strong>val_regularizer</strong>: double 1 x n vector (value of the regularization
term at the optimum).</li>
<li><strong>val_loss</strong>: vector of size U.shape[1]
alpha = spams.proximalFlat(U,return_val_loss = False,…)
(alpha,val_loss) = spams.proximalFlat(U,return_val_loss = True,…)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2010 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Valid values for the regularization parameter (regul) are:
“l0”, “l1”, “l2”, “linf”, “l2-not-squared”, “elastic-net”, “fused-lasso”,
“group-lasso-l2”, “group-lasso-linf”, “sparse-group-lasso-l2”,
“sparse-group-lasso-linf”, “l1l2”, “l1linf”, “l1l2+l1”, “l1linf+l1”,
“tree-l0”, “tree-l2”, “tree-linf”, “graph”, “graph-ridge”, “graph-l2”,
“multi-task-tree”, “multi-task-graph”, “l1linf-row-column”, “trace-norm”,
“trace-norm-vec”, “rank”, “rank-vec”, “none”</p>
</div>
</dd></dl>

</div>
<div class="section" id="proximaltree">
<h2>proximalTree<a class="headerlink" href="#proximaltree" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.proximalTree">
<code class="descclassname">spams.</code><code class="descname">proximalTree</code><span class="sig-paren">(</span><em>U</em>, <em>tree</em>, <em>return_val_loss=False</em>, <em>numThreads=-1</em>, <em>lambda1=1.0</em>, <em>lambda2=0.0</em>, <em>lambda3=0.0</em>, <em>intercept=False</em>, <em>resetflow=False</em>, <em>regul=''</em>, <em>verbose=False</em>, <em>pos=False</em>, <em>clever=True</em>, <em>size_group=1</em>, <em>transpose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.proximalTree" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>proximalTree computes a proximal operator. Depending</dt>
<dd><p class="first">on the value of regul, it computes</p>
<p>Given an input matrix U=[u^1,ldots,u^n], and a tree-structured set of groups T,
it returns a matrix V=[v^1,ldots,v^n]:</p>
<p>when the regularization function is for vectors,
for every column u of U, it compute a column v of V solving
if regul=’tree-l0’</p>
<blockquote>
<div>argmin 0.5||u-v||_2^2 + lambda1 sum_{g in T} delta^g(v)</div></blockquote>
<dl class="docutils">
<dt>if regul=’tree-l2’</dt>
<dd><dl class="first last docutils">
<dt>for all i, v^i = </dt>
<dd>argmin 0.5||u-v||_2^2 + lambda1sum_{g in T} eta_g||v_g||_2</dd>
</dl>
</dd>
<dt>if regul=’tree-linf’</dt>
<dd><dl class="first last docutils">
<dt>for all i, v^i = </dt>
<dd>argmin 0.5||u-v||_2^2 + lambda1sum_{g in T} eta_g||v_g||_inf</dd>
</dl>
</dd>
</dl>
<p>when the regularization function is for matrices:
if regul=’multi-task-tree’</p>
<blockquote>
<div><dl class="docutils">
<dt>V=argmin 0.5||U-V||_F^2 + lambda1 sum_{i=1}^nsum_{g in T} eta_g||v^i_g||_inf + …</dt>
<dd>lambda1_2 sum_{g in T} eta_g max_{j in g}||V_j||_{inf}</dd>
</dl>
</div></blockquote>
<p>it can also be used with any non-tree-structured regularization addressed by proximalFlat</p>
<p class="last">for all these regularizations, it is possible to enforce non-negativity constraints
with the option pos, and to prevent the last row of U to be regularized, with
the option intercept</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> – double m x n matrix   (input signals)
m is the signal size</li>
<li><strong>tree</strong> – <p>named list 
with four fields, eta_g, groups, own_variables and N_own_variables.</p>
<p>The tree structure requires a particular organization of groups and variables
* Let us denote by N = <a href="#id1"><span class="problematic" id="id2">|T|</span></a>, the number of groups.
the groups should be ordered T={g1,g2,ldots,gN} such that if gi is included
in gj, then j &lt;= i. g1 should be the group at the root of the tree 
and contains every variable.
* Every group is a set of  contiguous indices for instance 
gi={3,4,5} or gi={4,5,6,7} or gi={4}, but not {3,5};
* We define root(gi) as the indices of the variables that are in gi,
but not in its descendants. For instance for
T={ g1={1,2,3,4},g2={2,3},g3={4} }, then, root(g1)={1}, 
root(g2)={2,3}, root(g3)={4},
We assume that for all i, root(gi) is a set of contigous variables
* We assume that the smallest of root(gi) is also the smallest index of gi.</p>
<p>For instance, 
T={ g1={1,2,3,4},g2={2,3},g3={4} }, is a valid set of groups.
but we can not have
T={ g1={1,2,3,4},g2={1,2},g3={3} }, since root(g1)={4} and 4 is not the
smallest element in g1.</p>
<p>We do not lose generality with these assumptions since they can be fullfilled for any
tree-structured set of groups after a permutation of variables and a correct ordering of the
groups.
see more examples in test_ProximalTree.m of valid tree-structured sets of groups.</p>
<p>The first fields sets the weights for every group
tree[‘eta_g’]            double N vector</p>
<p>The next field sets inclusion relations between groups 
(but not between groups and variables):
tree[‘groups’]           sparse (double or boolean) N x N matrix  
the (i,j) entry is non-zero if and only if i is different than j and 
gi is included in gj.
the first column corresponds to the group at the root of the tree.</p>
<p>The next field define the smallest index of each group gi, 
which is also the smallest index of root(gi)
tree[‘own_variables’]    int32 N vector</p>
<p>The next field define for each group gi, the size of root(gi)
tree[‘N_own_variables’]  int32 N vector</p>
<p>examples are given in test_ProximalTree.m</p>
</li>
<li><strong>return_val_loss</strong> – if true the function will return a tuple of matrices.</li>
<li><strong>lambda1</strong> – (regularization parameter)</li>
<li><strong>regul</strong> – (choice of regularization, see above)</li>
<li><strong>lambda2</strong> – (optional, regularization parameter)</li>
<li><strong>lambda3</strong> – (optional, regularization parameter)</li>
<li><strong>verbose</strong> – (optional, verbosity level, false by default)</li>
<li><strong>intercept</strong> – (optional, last row of U is not regularized,
false by default)</li>
<li><strong>pos</strong> – (optional, adds positivity constraints on the
coefficients, false by default)</li>
<li><strong>transpose</strong> – (optional, transpose the matrix in the regularization function)</li>
<li><strong>size_group</strong> – (optional, for regularization functions assuming a group
structure). It is a scalar. When groups is not specified, it assumes
that the groups are the sets of consecutive elements of size size_group</li>
<li><strong>numThreads</strong> – (optional, number of threads for exploiting
multi-core / multi-cpus. By default, it takes the value -1,
which automatically selects all the available CPUs/cores).</li>
<li><strong>resetflow</strong> – undocumented; modify at your own risks!</li>
<li><strong>clever</strong> – undocumented; modify at your own risks!</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>V</strong>: double m x n matrix (output coefficients)</li>
<li><strong>val_regularizer</strong>: double 1 x n vector (value of the regularization
term at the optimum).</li>
<li><strong>val_loss</strong>: vector of size U.shape[1]
alpha = spams.proximalTree(U,tree,return_val_loss = False,…)
(alpha,val_loss) = spams.proximalTree(U,tree,return_val_loss = True,…)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2010 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Valid values for the regularization parameter (regul) are:
“l0”, “l1”, “l2”, “linf”, “l2-not-squared”, “elastic-net”, “fused-lasso”,
“group-lasso-l2”, “group-lasso-linf”, “sparse-group-lasso-l2”,
“sparse-group-lasso-linf”, “l1l2”, “l1linf”, “l1l2+l1”, “l1linf+l1”,
“tree-l0”, “tree-l2”, “tree-linf”, “graph”, “graph-ridge”, “graph-l2”,
“multi-task-tree”, “multi-task-graph”, “l1linf-row-column”, “trace-norm”,
“trace-norm-vec”, “rank”, “rank-vec”, “none”</p>
</div>
</dd></dl>

</div>
<div class="section" id="proximalgraph">
<h2>proximalGraph<a class="headerlink" href="#proximalgraph" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.proximalGraph">
<code class="descclassname">spams.</code><code class="descname">proximalGraph</code><span class="sig-paren">(</span><em>U</em>, <em>graph</em>, <em>return_val_loss=False</em>, <em>numThreads=-1</em>, <em>lambda1=1.0</em>, <em>lambda2=0.0</em>, <em>lambda3=0.0</em>, <em>intercept=False</em>, <em>resetflow=False</em>, <em>regul=''</em>, <em>verbose=False</em>, <em>pos=False</em>, <em>clever=True</em>, <em>eval=None</em>, <em>size_group=1</em>, <em>transpose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.proximalGraph" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>proximalGraph computes a proximal operator. Depending</dt>
<dd><p class="first">on the value of regul, it computes</p>
<p>Given an input matrix U=[u^1,ldots,u^n], and a set of groups G,
it computes a matrix V=[v^1,ldots,v^n] such that</p>
<p>if regul=’graph’
for every column u of U, it computes a column v of V solving</p>
<blockquote>
<div>argmin 0.5||u-v||_2^2 + lambda1sum_{g in G} eta_g||v_g||_inf</div></blockquote>
<p>if regul=’graph+ridge’
for every column u of U, it computes a column v of V solving</p>
<blockquote>
<div>argmin 0.5||u-v||_2^2 + lambda1sum_{g in G} eta_g||v_g||_inf + lambda1_2||v||_2^2</div></blockquote>
<dl class="docutils">
<dt>if regul=’multi-task-graph’</dt>
<dd><dl class="first last docutils">
<dt>V=argmin 0.5||U-V||_F^2 + lambda1 sum_{i=1}^nsum_{g in G} eta_g||v^i_g||_inf + …</dt>
<dd>lambda1_2 sum_{g in G} eta_g max_{j in g}||V_j||_{inf}</dd>
</dl>
</dd>
</dl>
<p>it can also be used with any regularization addressed by proximalFlat</p>
<p class="last">for all these regularizations, it is possible to enforce non-negativity constraints
with the option pos, and to prevent the last row of U to be regularized, with
the option intercept</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>U</strong> – double p x n matrix   (input signals)
m is the signal size</li>
<li><strong>graph</strong> – <p>struct
with three fields, eta_g, groups, and groups_var</p>
<p>The first fields sets the weights for every group
graph.eta_g            double N vector</p>
<p>The next field sets inclusion relations between groups 
(but not between groups and variables):
graph.groups           sparse (double or boolean) N x N matrix  
the (i,j) entry is non-zero if and only if i is different than j and 
gi is included in gj.</p>
<p>The next field sets inclusion relations between groups and variables
graph.groups_var       sparse (double or boolean) p x N matrix
the (i,j) entry is non-zero if and only if the variable i is included 
in gj, but not in any children of gj.</p>
<p>examples are given in test_ProximalGraph.m</p>
</li>
<li><strong>return_val_loss</strong> – if true the function will return a tuple of matrices.</li>
<li><strong>lambda1</strong> – (regularization parameter)</li>
<li><strong>regul</strong> – (choice of regularization, see above)</li>
<li><strong>lambda2</strong> – (optional, regularization parameter)</li>
<li><strong>lambda3</strong> – (optional, regularization parameter)</li>
<li><strong>verbose</strong> – (optional, verbosity level, false by default)</li>
<li><strong>intercept</strong> – (optional, last row of U is not regularized,
false by default)</li>
<li><strong>pos</strong> – (optional, adds positivity constraints on the
coefficients, false by default)</li>
<li><strong>numThreads</strong> – (optional, number of threads for exploiting
multi-core / multi-cpus. By default, it takes the value -1,
which automatically selects all the available CPUs/cores).</li>
<li><strong>resetflow</strong> – undocumented; modify at your own risks!</li>
<li><strong>clever</strong> – undocumented; modify at your own risks!</li>
<li><strong>size_group</strong> – undocumented; modify at your own risks!</li>
<li><strong>transpose</strong> – undocumented; modify at your own risks!</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>V</strong>: double p x n matrix (output coefficients)</li>
<li><strong>val_regularizer</strong>: double 1 x n vector (value of the regularization
term at the optimum).</li>
<li><strong>val_loss</strong>: vector of size U.shape[1]
alpha = spams.proximalGraph(U,graph,return_val_loss = False,…)
(alpha,val_loss) = spams.proximalGraph(U,graph,return_val_loss = True,…)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2010 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Valid values for the regularization parameter (regul) are:
“l0”, “l1”, “l2”, “linf”, “l2-not-squared”, “elastic-net”, “fused-lasso”,
“group-lasso-l2”, “group-lasso-linf”, “sparse-group-lasso-l2”,
“sparse-group-lasso-linf”, “l1l2”, “l1linf”, “l1l2+l1”, “l1linf+l1”,
“tree-l0”, “tree-l2”, “tree-linf”, “graph”, “graph-ridge”, “graph-l2”,
“multi-task-tree”, “multi-task-graph”, “l1linf-row-column”, “trace-norm”,
“trace-norm-vec”, “rank”, “rank-vec”, “none”</p>
</div>
</dd></dl>

</div>
<div class="section" id="traindl">
<h2>trainDL<a class="headerlink" href="#traindl" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.trainDL">
<code class="descclassname">spams.</code><code class="descname">trainDL</code><span class="sig-paren">(</span><em>X</em>, <em>return_model=False</em>, <em>model=None</em>, <em>D=None</em>, <em>numThreads=-1</em>, <em>batchsize=-1</em>, <em>K=-1</em>, <em>lambda1=None</em>, <em>lambda2=1e-09</em>, <em>iter=-1</em>, <em>t0=1e-05</em>, <em>mode=2</em>, <em>posAlpha=False</em>, <em>posD=False</em>, <em>expand=False</em>, <em>modeD=0</em>, <em>whiten=False</em>, <em>clean=True</em>, <em>verbose=True</em>, <em>gamma1=0.0</em>, <em>gamma2=0.0</em>, <em>rho=1.0</em>, <em>iter_updateD=None</em>, <em>stochastic_deprecated=False</em>, <em>modeParam=0</em>, <em>batch=False</em>, <em>log_deprecated=False</em>, <em>logName=''</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.trainDL" title="Permalink to this definition">¶</a></dt>
<dd><p>trainDL is an efficient implementation of the
dictionary learning technique presented in</p>
<blockquote>
<div><p>“Online Learning for Matrix Factorization and Sparse Coding”
by Julien Mairal, Francis Bach, Jean Ponce and Guillermo Sapiro
arXiv:0908.0050</p>
<p>“Online Dictionary Learning for Sparse Coding”      
by Julien Mairal, Francis Bach, Jean Ponce and Guillermo Sapiro
ICML 2009.</p>
<p>Note that if you use mode=1 or 2, if the training set has a
reasonable size and you have enough memory on your computer, you 
should use trainDL_Memory instead.</p>
<dl class="docutils">
<dt>It addresses the dictionary learning problems</dt>
<dd><ol class="first last arabic simple">
<li>if mode=0</li>
</ol>
</dd>
<dt>min_{D in C} (1/n) sum_{i=1}^n (1/2)||x_i-Dalpha_i||_2^2  s.t. …</dt>
<dd><blockquote class="first">
<div>||alpha_i||_1 &lt;= lambda1</div></blockquote>
<ol class="last arabic simple" start="2">
<li>if mode=1</li>
</ol>
</dd>
<dt>min_{D in C} (1/n) sum_{i=1}^n  ||alpha_i||_1  s.t.  …</dt>
<dd><blockquote class="first">
<div>||x_i-Dalpha_i||_2^2 &lt;= lambda1</div></blockquote>
<ol class="last arabic simple" start="3">
<li>if mode=2</li>
</ol>
</dd>
<dt>min_{D in C} (1/n) sum_{i=1}^n (1/2)||x_i-Dalpha_i||_2^2 + … </dt>
<dd><blockquote class="first">
<div>lambda1||alpha_i||_1 + lambda1_2||alpha_i||_2^2</div></blockquote>
<ol class="last arabic simple" start="4">
<li>if mode=3, the sparse coding is done with OMP</li>
</ol>
</dd>
<dt>min_{D in C} (1/n) sum_{i=1}^n (1/2)||x_i-Dalpha_i||_2^2  s.t. … </dt>
<dd><blockquote class="first">
<div>||alpha_i||_0 &lt;= lambda1</div></blockquote>
<ol class="last arabic simple" start="5">
<li>if mode=4, the sparse coding is done with OMP</li>
</ol>
</dd>
<dt>min_{D in C} (1/n) sum_{i=1}^n  ||alpha_i||_0  s.t.  …</dt>
<dd><blockquote class="first">
<div>||x_i-Dalpha_i||_2^2 &lt;= lambda1</div></blockquote>
<ol class="last arabic simple" start="6">
<li>if mode=5, the sparse coding is done with OMP</li>
</ol>
</dd>
</dl>
<p>min_{D in C} (1/n) sum_{i=1}^n 0.5||x_i-Dalpha_i||_2^2 +lambda1||alpha_i||_0</p>
<dl class="docutils">
<dt>C is a convex set verifying</dt>
<dd><ol class="first last arabic">
<li><p class="first">if modeD=0
C={  D in Real^{m x p}  s.t.  forall j,  ||d_j||_2^2 &lt;= 1 }</p>
</li>
<li><p class="first">if modeD=1
C={  D in Real^{m x p}  s.t.  forall j,  ||d_j||_2^2 + …</p>
<blockquote>
<div><p>gamma1||d_j||_1 &lt;= 1 }</p>
</div></blockquote>
</li>
<li><p class="first">if modeD=2
C={  D in Real^{m x p}  s.t.  forall j,  ||d_j||_2^2 + …</p>
<blockquote>
<div><p>gamma1||d_j||_1 + gamma2 FL(d_j) &lt;= 1 }</p>
</div></blockquote>
</li>
<li><p class="first">if modeD=3
C={  D in Real^{m x p}  s.t.  forall j,  (1-gamma1)||d_j||_2^2 + …</p>
<blockquote>
<div><p>gamma1||d_j||_1 &lt;= 1 }</p>
</div></blockquote>
</li>
</ol>
</dd>
</dl>
<p>Potentially, n can be very large with this algorithm.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> – double m x n matrix   (input signals)
m is the signal size
n is the number of signals to decompose</li>
<li><strong>return_model</strong> – if true the function will return the model
as a named list (‘A’ = A, ‘B’ = B, ‘iter’ = n)</li>
<li><strong>model</strong> – None or model (as A,B,iter) to use as initialisation</li>
<li><strong>D</strong> – (optional) double m x p matrix   (dictionary)
p is the number of elements in the dictionary
When D is not provided, the dictionary is initialized 
with random elements from the training set.</li>
<li><strong>K</strong> – (size of the dictionary, optional is D is provided)</li>
<li><strong>lambda1</strong> – (parameter)</li>
<li><strong>lambda2</strong> – (optional, by default 0)</li>
<li><strong>iter</strong> – (number of iterations).  If a negative number is 
provided it will perform the computation during the
corresponding number of seconds. For instance iter=-5
learns the dictionary during 5 seconds.</li>
<li><strong>mode</strong> – (optional, see above, by default 2)</li>
<li><strong>posAlpha</strong> – (optional, adds positivity constraints on the
coefficients, false by default, not compatible with 
mode =3,4)</li>
<li><strong>modeD</strong> – (optional, see above, by default 0)</li>
<li><strong>posD</strong> – (optional, adds positivity constraints on the 
dictionary, false by default, not compatible with 
modeD=2)</li>
<li><strong>gamma1</strong> – (optional parameter for modeD &gt;= 1)</li>
<li><strong>gamma2</strong> – (optional parameter for modeD = 2)</li>
<li><strong>batchsize</strong> – (optional, size of the minibatch, by default 
512)</li>
<li><strong>iter_updateD</strong> – (optional, number of BCD iterations for the dictionary
update step, by default 1)</li>
<li><strong>modeParam</strong> – (optimization mode).
1) if modeParam=0, the optimization uses the 
parameter free strategy of the ICML paper
2) if modeParam=1, the optimization uses the 
parameters rho as in arXiv:0908.0050
3) if modeParam=2, the optimization uses exponential 
decay weights with updates of the form 
A_{t} &lt;- rho A_{t-1} + alpha_t alpha_t^T</li>
<li><strong>rho</strong> – (optional) tuning parameter (see paper arXiv:0908.0050)</li>
<li><strong>t0</strong> – (optional) tuning parameter (see paper arXiv:0908.0050)</li>
<li><strong>clean</strong> – (optional, true by default. prunes 
automatically the dictionary from unused elements).</li>
<li><strong>verbose</strong> – (optional, true by default, increase verbosity)</li>
<li><strong>numThreads</strong> – (optional, number of threads for exploiting
multi-core / multi-cpus. By default, it takes the value -1,
which automatically selects all the available CPUs/cores).</li>
<li><strong>expand</strong> – undocumented; modify at your own risks!</li>
<li><strong>whiten</strong> – undocumented; modify at your own risks!</li>
<li><strong>stochastic_deprecated</strong> – undocumented; modify at your own risks!</li>
<li><strong>batch</strong> – undocumented; modify at your own risks!</li>
<li><strong>log_deprecated</strong> – undocumented; modify at your own risks!</li>
<li><strong>logName</strong> – undocumented; modify at your own risks!</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>D</strong>: double m x p matrix   (dictionary)</li>
<li><strong>model</strong>: the model as A B iter
D = spams.trainDL(X,return_model = False,…)
(D,model) = spams.trainDL(X,return_model = True,…)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2009 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this function admits a few experimental usages, which have not
been extensively tested:
- single precision setting</p>
</div>
</dd></dl>

</div>
<div class="section" id="structtraindl">
<h2>structTrainDL<a class="headerlink" href="#structtraindl" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.structTrainDL">
<code class="descclassname">spams.</code><code class="descname">structTrainDL</code><span class="sig-paren">(</span><em>X</em>, <em>return_model=False</em>, <em>model=None</em>, <em>D=None</em>, <em>graph=None</em>, <em>tree=None</em>, <em>numThreads=-1</em>, <em>tol=1e-06</em>, <em>fixed_step=True</em>, <em>ista=False</em>, <em>batchsize=-1</em>, <em>K=-1</em>, <em>lambda1=None</em>, <em>lambda2=1e-09</em>, <em>lambda3=0.0</em>, <em>iter=-1</em>, <em>t0=1e-05</em>, <em>regul='none'</em>, <em>posAlpha=False</em>, <em>posD=False</em>, <em>expand=False</em>, <em>modeD=0</em>, <em>whiten=False</em>, <em>clean=True</em>, <em>verbose=True</em>, <em>gamma1=0.0</em>, <em>gamma2=0.0</em>, <em>rho=1.0</em>, <em>iter_updateD=None</em>, <em>stochastic_deprecated=False</em>, <em>modeParam=0</em>, <em>batch=False</em>, <em>log_deprecated=False</em>, <em>logName=''</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.structTrainDL" title="Permalink to this definition">¶</a></dt>
<dd><p>structTrainDL is an efficient implementation of the
dictionary learning technique presented in</p>
<blockquote>
<div><p>“Online Learning for Matrix Factorization and Sparse Coding”
by Julien Mairal, Francis Bach, Jean Ponce and Guillermo Sapiro
arXiv:0908.0050</p>
<p>“Online Dictionary Learning for Sparse Coding”      
by Julien Mairal, Francis Bach, Jean Ponce and Guillermo Sapiro
ICML 2009.</p>
<dl class="docutils">
<dt>It addresses the dictionary learning problems</dt>
<dd><p class="first">min_{D in C} (1/n) sum_{i=1}^n 0.5||x_i-Dalpha_i||_2^2 + lambda1 psi(alpha)
where the regularization function psi depends on regul
(see proximalFlat for the description of psi,</p>
<blockquote class="last">
<div>and regul below for allowed values of regul)</div></blockquote>
</dd>
<dt>C is a convex set verifying</dt>
<dd><ol class="first last arabic">
<li><p class="first">if modeD=0
C={  D in Real^{m x p}  s.t.  forall j,  ||d_j||_2^2 &lt;= 1 }</p>
</li>
<li><p class="first">if modeD=1
C={  D in Real^{m x p}  s.t.  forall j,  ||d_j||_2^2 + …</p>
<blockquote>
<div><p>gamma1||d_j||_1 &lt;= 1 }</p>
</div></blockquote>
</li>
<li><p class="first">if modeD=2
C={  D in Real^{m x p}  s.t.  forall j,  ||d_j||_2^2 + …</p>
<blockquote>
<div><p>gamma1||d_j||_1 + gamma2 FL(d_j) &lt;= 1 }</p>
</div></blockquote>
</li>
<li><p class="first">if modeD=3
C={  D in Real^{m x p}  s.t.  forall j,  (1-gamma1)||d_j||_2^2 + …</p>
<blockquote>
<div><p>gamma1||d_j||_1 &lt;= 1 }</p>
</div></blockquote>
</li>
</ol>
</dd>
</dl>
<p>Potentially, n can be very large with this algorithm.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> – double m x n matrix   (input signals)
m is the signal size
n is the number of signals to decompose</li>
<li><strong>return_model</strong> – if true the function will return the model
as a named list (‘A’ = A, ‘B’ = B, ‘iter’ = n)</li>
<li><strong>model</strong> – None or model (as A,B,iter) to use as initialisation</li>
<li><strong>D</strong> – (optional) double m x p matrix   (dictionary)
p is the number of elements in the dictionary
When D is not provided, the dictionary is initialized 
with random elements from the training set.</li>
<li><strong>K</strong> – (size of the dictionary, optional is D is provided)</li>
<li><strong>lambda1</strong> – (parameter)</li>
<li><strong>lambda2</strong> – (optional, by default 0)</li>
<li><strong>lambda3</strong> – (optional, regularization parameter, 0 by default)</li>
<li><strong>iter</strong> – (number of iterations).  If a negative number is 
provided it will perform the computation during the
corresponding number of seconds. For instance iter=-5
learns the dictionary during 5 seconds.</li>
<li><strong>regul</strong> – choice of regularization : one of
‘l0’ ‘l1’ ‘l2’ ‘linf’ ‘none’ ‘elastic-net’ ‘fused-lasso’
‘graph’ ‘graph-ridge’ ‘graph-l2’ ‘tree-l0’ ‘tree-l2’ ‘tree-linf’</li>
<li><strong>tree</strong> – struct (see documentation of proximalTree);
needed for regul of graph kind.</li>
<li><strong>graph</strong> – struct (see documentation of proximalGraph);
needed for regul of tree kind.</li>
<li><strong>posAlpha</strong> – (optional, adds positivity constraints on the
coefficients, false by default.</li>
<li><strong>modeD</strong> – (optional, see above, by default 0)</li>
<li><strong>posD</strong> – (optional, adds positivity constraints on the 
dictionary, false by default, not compatible with 
modeD=2)</li>
<li><strong>gamma1</strong> – (optional parameter for modeD &gt;= 1)</li>
<li><strong>gamma2</strong> – (optional parameter for modeD = 2)</li>
<li><strong>batchsize</strong> – (optional, size of the minibatch, by default 
512)</li>
<li><strong>iter_updateD</strong> – (optional, number of BCD iterations for the dictionary
update step, by default 1)</li>
<li><strong>modeParam</strong> – (optimization mode).
1) if modeParam=0, the optimization uses the 
parameter free strategy of the ICML paper
2) if modeParam=1, the optimization uses the 
parameters rho as in arXiv:0908.0050
3) if modeParam=2, the optimization uses exponential 
decay weights with updates of the form 
A_{t} &lt;- rho A_{t-1} + alpha_t alpha_t^T</li>
<li><strong>ista</strong> – (optional, use ista instead of fista, false by default).</li>
<li><strong>tol</strong> – (optional, tolerance for stopping criteration, which is a relative duality gap</li>
<li><strong>fixed_step</strong> – (deactive the line search for L in fista and use K instead)</li>
<li><strong>rho</strong> – (optional) tuning parameter (see paper arXiv:0908.0050)</li>
<li><strong>t0</strong> – (optional) tuning parameter (see paper arXiv:0908.0050)</li>
<li><strong>clean</strong> – (optional, true by default. prunes 
automatically the dictionary from unused elements).</li>
<li><strong>verbose</strong> – (optional, true by default, increase verbosity)</li>
<li><strong>numThreads</strong> – (optional, number of threads for exploiting
multi-core / multi-cpus. By default, it takes the value -1,
which automatically selects all the available CPUs/cores).</li>
<li><strong>expand</strong> – undocumented; modify at your own risks!</li>
<li><strong>whiten</strong> – undocumented; modify at your own risks!</li>
<li><strong>stochastic_deprecated</strong> – undocumented; modify at your own risks!</li>
<li><strong>batch</strong> – undocumented; modify at your own risks!</li>
<li><strong>log_deprecated</strong> – undocumented; modify at your own risks!</li>
<li><strong>logName</strong> – undocumented; modify at your own risks!</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>D</strong>: double m x p matrix   (dictionary)</li>
<li><strong>model</strong>: the model as A B iter
D = spams.structTrainDL(X,return_model = False,…)
(D,model) = spams.structTrainDL(X,return_model = True,…)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2009 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this function admits a few experimental usages, which have not
been extensively tested:
- single precision setting</p>
</div>
</dd></dl>

</div>
<div class="section" id="traindl-memory">
<h2>trainDL_Memory<a class="headerlink" href="#traindl-memory" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.trainDL_Memory">
<code class="descclassname">spams.</code><code class="descname">trainDL_Memory</code><span class="sig-paren">(</span><em>X</em>, <em>D=None</em>, <em>numThreads=-1</em>, <em>batchsize=-1</em>, <em>K=-1</em>, <em>lambda1=None</em>, <em>iter=-1</em>, <em>t0=1e-05</em>, <em>mode=2</em>, <em>posD=False</em>, <em>expand=False</em>, <em>modeD=0</em>, <em>whiten=False</em>, <em>clean=True</em>, <em>gamma1=0.0</em>, <em>gamma2=0.0</em>, <em>rho=1.0</em>, <em>iter_updateD=1</em>, <em>stochastic_deprecated=False</em>, <em>modeParam=0</em>, <em>batch=False</em>, <em>log_deprecated=False</em>, <em>logName=''</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.trainDL_Memory" title="Permalink to this definition">¶</a></dt>
<dd><p>trainDL_Memory is an efficient but memory consuming 
variant of the dictionary learning technique presented in</p>
<blockquote>
<div><p>“Online Learning for Matrix Factorization and Sparse Coding”
by Julien Mairal, Francis Bach, Jean Ponce and Guillermo Sapiro
arXiv:0908.0050</p>
<p>“Online Dictionary Learning for Sparse Coding”      
by Julien Mairal, Francis Bach, Jean Ponce and Guillermo Sapiro
ICML 2009.</p>
<dl class="docutils">
<dt>Contrary to the approaches above, the algorithm here </dt>
<dd>does require to store all the coefficients from all the training
signals. For this reason this variant can not be used with large
training sets, but is more efficient than the regular online
approach for training sets of reasonable size.</dd>
<dt>It addresses the dictionary learning problems</dt>
<dd><ol class="first last arabic simple">
<li>if mode=1</li>
</ol>
</dd>
<dt>min_{D in C} (1/n) sum_{i=1}^n  ||alpha_i||_1  s.t.  …</dt>
<dd><blockquote class="first">
<div>||x_i-Dalpha_i||_2^2 &lt;= lambda1</div></blockquote>
<ol class="last arabic simple" start="2">
<li>if mode=2</li>
</ol>
</dd>
<dt>min_{D in C} (1/n) sum_{i=1}^n (1/2)||x_i-Dalpha_i||_2^2 + … </dt>
<dd>lambda1||alpha_i||_1</dd>
<dt>C is a convex set verifying</dt>
<dd><ol class="first arabic simple">
<li>if modeD=0
C={  D in Real^{m x p}  s.t.  forall j,  ||d_j||_2^2 &lt;= 1 }</li>
</ol>
<ol class="arabic">
<li><p class="first">if modeD=1
C={  D in Real^{m x p}  s.t.  forall j,  ||d_j||_2^2 + …</p>
<blockquote>
<div><p>gamma1||d_j||_1 &lt;= 1 }</p>
</div></blockquote>
</li>
</ol>
<ol class="last arabic">
<li><p class="first">if modeD=2
C={  D in Real^{m x p}  s.t.  forall j,  ||d_j||_2^2 + …</p>
<blockquote>
<div><p>gamma1||d_j||_1 + gamma2 FL(d_j) &lt;= 1 }</p>
</div></blockquote>
</li>
</ol>
</dd>
</dl>
<p>Potentially, n can be very large with this algorithm.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> – double m x n matrix   (input signals)
m is the signal size
n is the number of signals to decompose</li>
<li><strong>D</strong> – (optional) double m x p matrix   (dictionary)
p is the number of elements in the dictionary
When D is not provided, the dictionary is initialized 
with random elements from the training set.</li>
<li><strong>K</strong> – (size of the dictionary, optional is D is provided)</li>
<li><strong>lambda1</strong> – (parameter)</li>
<li><strong>iter</strong> – (number of iterations).  If a negative number is 
provided it will perform the computation during the
corresponding number of seconds. For instance iter=-5
learns the dictionary during 5 seconds.</li>
<li><strong>mode</strong> – (optional, see above, by default 2)</li>
<li><strong>modeD</strong> – (optional, see above, by default 0)</li>
<li><strong>posD</strong> – (optional, adds positivity constraints on the 
dictionary, false by default, not compatible with 
modeD=2)</li>
<li><strong>gamma1</strong> – (optional parameter for modeD &gt;= 1)</li>
<li><strong>gamma2</strong> – (optional parameter for modeD = 2)</li>
<li><strong>batchsize</strong> – (optional, size of the minibatch, by default 
512)</li>
<li><strong>iter_updateD</strong> – (optional, number of BCD iterations for the dictionary 
update step, by default 1)</li>
<li><strong>modeParam</strong> – (optimization mode).
1) if modeParam=0, the optimization uses the 
parameter free strategy of the ICML paper
2) if modeParam=1, the optimization uses the 
parameters rho as in arXiv:0908.0050
3) if modeParam=2, the optimization uses exponential 
decay weights with updates of the form 
A_{t} &lt;- rho A_{t-1} + alpha_t alpha_t^T</li>
<li><strong>rho</strong> – (optional) tuning parameter (see paper arXiv:0908.0050)</li>
<li><strong>t0</strong> – (optional) tuning parameter (see paper arXiv:0908.0050)</li>
<li><strong>clean</strong> – (optional, true by default. prunes 
automatically the dictionary from unused elements).</li>
<li><strong>numThreads</strong> – (optional, number of threads for exploiting
multi-core / multi-cpus. By default, it takes the value -1,
which automatically selects all the available CPUs/cores).</li>
<li><strong>expand</strong> – undocumented; modify at your own risks!</li>
<li><strong>whiten</strong> – undocumented; modify at your own risks!</li>
<li><strong>stochastic_deprecated</strong> – undocumented; modify at your own risks!</li>
<li><strong>batch</strong> – undocumented; modify at your own risks!</li>
<li><strong>log_deprecated</strong> – undocumented; modify at your own risks!</li>
<li><strong>logName</strong> – undocumented; modify at your own risks!</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>D</strong>: double m x p matrix   (dictionary)</li>
<li><strong>model</strong>: the model as A B iter
D = spams.trainDL_Memory(X,…)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2009 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this function admits a few experimental usages, which have not
been extensively tested:
- single precision setting (even though the output alpha is double 
precision)</p>
</div>
</dd></dl>

</div>
<div class="section" id="nmf">
<h2>nmf<a class="headerlink" href="#nmf" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.nmf">
<code class="descclassname">spams.</code><code class="descname">nmf</code><span class="sig-paren">(</span><em>X</em>, <em>return_lasso=False</em>, <em>model=None</em>, <em>numThreads=-1</em>, <em>batchsize=-1</em>, <em>K=-1</em>, <em>iter=-1</em>, <em>t0=1e-05</em>, <em>clean=True</em>, <em>rho=1.0</em>, <em>modeParam=0</em>, <em>batch=False</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.nmf" title="Permalink to this definition">¶</a></dt>
<dd><p>trainDL is an efficient implementation of the
non-negative matrix factorization technique presented in</p>
<blockquote>
<div><p>“Online Learning for Matrix Factorization and Sparse Coding”
by Julien Mairal, Francis Bach, Jean Ponce and Guillermo Sapiro
arXiv:0908.0050</p>
<p>“Online Dictionary Learning for Sparse Coding”      
by Julien Mairal, Francis Bach, Jean Ponce and Guillermo Sapiro
ICML 2009.</p>
<p>Potentially, n can be very large with this algorithm.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> – double m x n matrix   (input signals)
m is the signal size
n is the number of signals to decompose</li>
<li><strong>return_lasso</strong> – if true the function will return a tuple of matrices.</li>
<li><strong>K</strong> – (number of required factors)</li>
<li><strong>iter</strong> – (number of iterations).  If a negative number 
is provided it will perform the computation during the
corresponding number of seconds. For instance iter=-5
learns the dictionary during 5 seconds.</li>
<li><strong>batchsize</strong> – (optional, size of the minibatch, by default 
512)</li>
<li><strong>modeParam</strong> – (optimization mode).
1) if modeParam=0, the optimization uses the 
parameter free strategy of the ICML paper
2) if modeParam=1, the optimization uses the 
parameters rho as in arXiv:0908.0050
3) if modeParam=2, the optimization uses exponential 
decay weights with updates of the form  
A_{t} &lt;- rho A_{t-1} + alpha_t alpha_t^T</li>
<li><strong>rho</strong> – (optional) tuning parameter (see paper 
arXiv:0908.0050)</li>
<li><strong>t0</strong> – (optional) tuning parameter (see paper 
arXiv:0908.0050)</li>
<li><strong>clean</strong> – (optional, true by default. prunes automatically 
the dictionary from unused elements).</li>
<li><strong>batch</strong> – (optional, false by default, use batch learning 
instead of online learning)</li>
<li><strong>numThreads</strong> – (optional, number of threads for exploiting
multi-core / multi-cpus. By default, it takes the value -1,
which automatically selects all the available CPUs/cores).</li>
<li><strong>model</strong> – struct (optional) learned model for “retraining” the data.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>U</strong>: double m x p matrix</li>
<li><strong>V</strong>: double p x n matrix   (optional)</li>
<li><strong>model</strong>: struct (optional) learned model to be used for 
“retraining” the data.
U = spams.nmf(X,return_lasso = False,…)
(U,V) = spams.nmf(X,return_lasso = True,…)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2009 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="nnsc">
<h2>nnsc<a class="headerlink" href="#nnsc" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.nnsc">
<code class="descclassname">spams.</code><code class="descname">nnsc</code><span class="sig-paren">(</span><em>X</em>, <em>return_lasso=False</em>, <em>model=None</em>, <em>lambda1=None</em>, <em>numThreads=-1</em>, <em>batchsize=-1</em>, <em>K=-1</em>, <em>iter=-1</em>, <em>t0=1e-05</em>, <em>clean=True</em>, <em>rho=1.0</em>, <em>modeParam=0</em>, <em>batch=False</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.nnsc" title="Permalink to this definition">¶</a></dt>
<dd><p>trainDL is an efficient implementation of the
non-negative sparse coding technique presented in</p>
<blockquote>
<div><p>“Online Learning for Matrix Factorization and Sparse Coding”
by Julien Mairal, Francis Bach, Jean Ponce and Guillermo Sapiro
arXiv:0908.0050</p>
<p>“Online Dictionary Learning for Sparse Coding”      
by Julien Mairal, Francis Bach, Jean Ponce and Guillermo Sapiro
ICML 2009.</p>
<p>Potentially, n can be very large with this algorithm.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> – double m x n matrix   (input signals)
m is the signal size
n is the number of signals to decompose</li>
<li><strong>return_lasso</strong> – if true the function will return a tuple of matrices.</li>
<li><strong>K</strong> – (number of required factors)</li>
<li><strong>lambda1</strong> – (parameter)</li>
<li><strong>iter</strong> – (number of iterations).  If a negative number 
is provided it will perform the computation during the
corresponding number of seconds. For instance iter=-5
learns the dictionary during 5 seconds.</li>
<li><strong>batchsize</strong> – (optional, size of the minibatch, by default 
512)</li>
<li><strong>modeParam</strong> – (optimization mode).
1) if modeParam=0, the optimization uses the 
parameter free strategy of the ICML paper
2) if modeParam=1, the optimization uses the 
parameters rho as in arXiv:0908.0050
3) if modeParam=2, the optimization uses exponential 
decay weights with updates of the form 
A_{t} &lt;- rho A_{t-1} + alpha_t alpha_t^T</li>
<li><strong>rho</strong> – (optional) tuning parameter (see paper
arXiv:0908.0050)</li>
<li><strong>t0</strong> – (optional) tuning parameter (see paper 
arXiv:0908.0050)</li>
<li><strong>clean</strong> – (optional, true by default. prunes automatically 
the dictionary from unused elements).</li>
<li><strong>batch</strong> – (optional, false by default, use batch learning 
instead of online learning)</li>
<li><strong>numThreads</strong> – (optional, number of threads for exploiting
multi-core / multi-cpus. By default, it takes the value -1,
which automatically selects all the available CPUs/cores).</li>
<li><strong>model</strong> – struct (optional) learned model for “retraining” the data.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>U</strong>: double m x p matrix</li>
<li><strong>V</strong>: double p x n matrix   (optional)</li>
<li><strong>model</strong>: struct (optional) learned model to be used for 
“retraining” the data.
U = spams.nnsc(X,return_lasso = False,…)
(U,V) = spams.nnsc(X,return_lasso = True,…)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Julien MAIRAL, 2009 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="archetypalanalysis">
<h2>archetypalAnalysis<a class="headerlink" href="#archetypalanalysis" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.archetypalAnalysis">
<code class="descclassname">spams.</code><code class="descname">archetypalAnalysis</code><span class="sig-paren">(</span><em>X</em>, <em>p=10</em>, <em>Z0=None</em>, <em>returnAB=False</em>, <em>robust=False</em>, <em>epsilon=0.001</em>, <em>computeXtX=False</em>, <em>stepsFISTA=3</em>, <em>stepsAS=50</em>, <em>randominit=False</em>, <em>numThreads=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.archetypalAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>documentation to appear soon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> – double m x n matrix   (input signals)
m is the signal size
n is the number of signals to decompose</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>Z</strong>: double %</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Yuansi Chen and Julien MAIRAL, 2014 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="decompsimplex">
<h2>decompSimplex<a class="headerlink" href="#decompsimplex" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.decompSimplex">
<code class="descclassname">spams.</code><code class="descname">decompSimplex</code><span class="sig-paren">(</span><em>X</em>, <em>Z</em>, <em>computeXtX=False</em>, <em>numThreads=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.decompSimplex" title="Permalink to this definition">¶</a></dt>
<dd><p>documentation to appear soon</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> – double m x n matrix   (input signals)
m is the signal size
n is the number of signals to decompose</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>Z</strong>: double %</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Yuansi Chen and Julien MAIRAL, 2014 (spams, matlab interface and documentation)</li>
<li>Jean-Paul CHIEZE 2011-2012 (python interface)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="simplegrouptree">
<h2>simpleGroupTree<a class="headerlink" href="#simplegrouptree" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.simpleGroupTree">
<code class="descclassname">spams.</code><code class="descname">simpleGroupTree</code><span class="sig-paren">(</span><em>degrees</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.simpleGroupTree" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>makes a structure representing a tree given the</dt>
<dd>degree of each level.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>degrees</strong> – int vector; degrees(i) is the number of children of each node at level i</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>group_struct</strong>: list, one element for each node
an element is itsel a 4 elements list :
nodeid (int &gt;= 0), weight (double), array of vars attached to the node
(here equal to [nodeid]), array of children (nodeid’s)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Jean-Paul CHIEZE, 2012</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="readgroupstruct">
<h2>readGroupStruct<a class="headerlink" href="#readgroupstruct" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.readGroupStruct">
<code class="descclassname">spams.</code><code class="descname">readGroupStruct</code><span class="sig-paren">(</span><em>file</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.readGroupStruct" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>reads a text file describing “simply” the structure of groups</dt>
<dd><p class="first">of variables needed by proximalGraph, proximalTree, fistaGraph,
fistaTree and structTrainDL and builds the corresponding group structure.</p>
<blockquote class="last">
<div><p>weight is a float
variables-list : a space separated list of integers, maybe empty,</p>
<blockquote>
<div>but ‘[‘ and ‘] must be present. Numbers in the range (0 - Nv-1)</div></blockquote>
<dl class="docutils">
<dt>children-list <span class="classifier-delimiter">:</span> <span class="classifier">a space separated list of node-id’s</span></dt>
<dd>If the list is empty, ‘-&gt;’ may be omitted.</dd>
<dt>The data must obey some rules <span class="classifier-delimiter">:</span> <span class="classifier"></span></dt>
<dd><ul class="first last simple">
<li>A group contains the variables of the corresponding node and of the whole subtree.</li>
<li>Variables attached to a node are those that are not int the subtree.</li>
<li><dl class="first docutils">
<dt>If the data destination is a Graph, there may be several independant trees,</dt>
<dd>and a varibale may appear in several trees.</dd>
</dl>
</li>
</ul>
</dd>
<dt>If the destination is a Tree, there must be only one tree, the root node</dt>
<dd>must have id == 0 and each variable must appear only once.</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>file</strong> – the file name</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>groups</strong>: list, one element for each node
an element is itsel a 4 elements list:
nodeid (int &gt;= 0), weight (double), array of vars of the node,
array of children (nodeid’s)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Jean-Paul CHIEZE, 2012</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="groupstructofstring">
<h2>groupStructOfString<a class="headerlink" href="#groupstructofstring" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.groupStructOfString">
<code class="descclassname">spams.</code><code class="descname">groupStructOfString</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.groupStructOfString" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>decode a multi-line string describing “simply” the structure of groups</dt>
<dd><p class="first">of variables needed by proximalGraph, proximalTree, fistaGraph,
fistaTree and structTrainDL and builds the corresponding group structure.</p>
<blockquote class="last">
<div><p>Each line describes a group of variables as a node of a tree.
It has up to 4 fields separated by spaces:</p>
<blockquote>
<div>node-id node-weight [variables-list] -&gt; children-list</div></blockquote>
<p>Let’s define Ng = number of groups, and Nv = number of variables.
node-id must be in the range (0 - Ng-1), and there must be Ng nodes
weight is a float
variables-list : a space separated list of integers, maybe empty,</p>
<blockquote>
<div>but ‘[‘ and ‘] must be present. Numbers in the range (0 - Nv-1)</div></blockquote>
<dl class="docutils">
<dt>children-list <span class="classifier-delimiter">:</span> <span class="classifier">a space separated list of node-id’s</span></dt>
<dd>If the list is empty, ‘-&gt;’ may be omitted.</dd>
<dt>The data must obey some rules <span class="classifier-delimiter">:</span> <span class="classifier"></span></dt>
<dd><ul class="first last simple">
<li>A group contains the variables of the corresponding node and of the whole subtree.</li>
<li>Variables attached to a node are those that are not int the subtree.</li>
<li>If the data destination is a Graph, there may be several independant trees,
and a varibale may appear in several trees.</li>
</ul>
</dd>
</dl>
<p>If the destination is a Tree, there must be only one tree, the root node
must have id == 0 and each variable must appear only once.</p>
</div></blockquote>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>s</strong> – the multi-lines string</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>groups</strong>: list, one element for each node
an element is itsel a 4 elements list:
nodeid (int &gt;= 0), weight (double), array of vars of the node,
array of children (nodeid’s)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Jean-Paul CHIEZE, 2012</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="graphofgroupstruct">
<h2>graphOfGroupStruct<a class="headerlink" href="#graphofgroupstruct" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.graphOfGroupStruct">
<code class="descclassname">spams.</code><code class="descname">graphOfGroupStruct</code><span class="sig-paren">(</span><em>gstruct</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.graphOfGroupStruct" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>converts a group structure into the graph structure</dt>
<dd>used by proximalGraph, fistaGraph or structTrainDL</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gstruct</strong> – the structure of groups as a list, one element per node
an element is itself a 4 elements list:
nodeid (&gt;= 0), weight (double), array of vars associated to the node,
array of children (nodeis’s)</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>graph</strong>: struct (see documentation of proximalGraph)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Jean-Paul CHIEZE, 2012</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="treeofgroupstruct">
<h2>treeOfGroupStruct<a class="headerlink" href="#treeofgroupstruct" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spams.treeOfGroupStruct">
<code class="descclassname">spams.</code><code class="descname">treeOfGroupStruct</code><span class="sig-paren">(</span><em>gstruct</em><span class="sig-paren">)</span><a class="headerlink" href="#spams.treeOfGroupStruct" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>converts a group structure into the tree structure</dt>
<dd>used by proximalTree, fistaTree or structTrainDL</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gstruct</strong> – the structure of groups as a list, one element per node
an element is itself a 4 lements list:
nodeid (&gt;= 0), weight (double), array of vars associated to the node,
array of children (nodeis’s)</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>permutations</strong>: permutation vector that must be applied to the result of the
programm using the tree. Empty if no permutation is needed.</li>
<li><strong>tree</strong>: named list (see documentation of proximalTree)</li>
<li><strong>nbvars</strong>: number of variables in the tree
(permutations,tree,nbvars) = spams.treeOfGroupStruct(gstruct)</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><ul class="first last simple">
<li>Jean-Paul CHIEZE, 2012</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></li>
<li><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">SPAMS’s python interface documentation</a><ul>
<li><a class="reference internal" href="#sort">sort</a></li>
<li><a class="reference internal" href="#calcaat">calcAAt</a></li>
<li><a class="reference internal" href="#calcxat">calcXAt</a></li>
<li><a class="reference internal" href="#calcxy">calcXY</a></li>
<li><a class="reference internal" href="#calcxyt">calcXYt</a></li>
<li><a class="reference internal" href="#calcxty">calcXtY</a></li>
<li><a class="reference internal" href="#bayer">bayer</a></li>
<li><a class="reference internal" href="#conjgrad">conjGrad</a></li>
<li><a class="reference internal" href="#invsym">invSym</a></li>
<li><a class="reference internal" href="#normalize">normalize</a></li>
<li><a class="reference internal" href="#sparseproject">sparseProject</a></li>
<li><a class="reference internal" href="#lasso">lasso</a></li>
<li><a class="reference internal" href="#lassomask">lassoMask</a></li>
<li><a class="reference internal" href="#lassoweighted">lassoWeighted</a></li>
<li><a class="reference internal" href="#omp">omp</a></li>
<li><a class="reference internal" href="#ompmask">ompMask</a></li>
<li><a class="reference internal" href="#cd">cd</a></li>
<li><a class="reference internal" href="#somp">somp</a></li>
<li><a class="reference internal" href="#l1l2bcd">l1L2BCD</a></li>
<li><a class="reference internal" href="#fistaflat">fistaFlat</a></li>
<li><a class="reference internal" href="#fistatree">fistaTree</a></li>
<li><a class="reference internal" href="#fistagraph">fistaGraph</a></li>
<li><a class="reference internal" href="#proximalflat">proximalFlat</a></li>
<li><a class="reference internal" href="#proximaltree">proximalTree</a></li>
<li><a class="reference internal" href="#proximalgraph">proximalGraph</a></li>
<li><a class="reference internal" href="#traindl">trainDL</a></li>
<li><a class="reference internal" href="#structtraindl">structTrainDL</a></li>
<li><a class="reference internal" href="#traindl-memory">trainDL_Memory</a></li>
<li><a class="reference internal" href="#nmf">nmf</a></li>
<li><a class="reference internal" href="#nnsc">nnsc</a></li>
<li><a class="reference internal" href="#archetypalanalysis">archetypalAnalysis</a></li>
<li><a class="reference internal" href="#decompsimplex">decompSimplex</a></li>
<li><a class="reference internal" href="#simplegrouptree">simpleGroupTree</a></li>
<li><a class="reference internal" href="#readgroupstruct">readGroupStruct</a></li>
<li><a class="reference internal" href="#groupstructofstring">groupStructOfString</a></li>
<li><a class="reference internal" href="#graphofgroupstruct">graphOfGroupStruct</a></li>
<li><a class="reference internal" href="#treeofgroupstruct">treeOfGroupStruct</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="#">SPAMS 1 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2012, jp.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>