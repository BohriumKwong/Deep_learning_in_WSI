# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
This module gives access to some functions of the spams C++ library.
The functions defined here should not be called directly.
Use of spams functions should only be done through module spams.
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_spams_wrap')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_spams_wrap')
    _spams_wrap = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_spams_wrap', [dirname(__file__)])
        except ImportError:
            import _spams_wrap
            return _spams_wrap
        try:
            _mod = imp.load_module('_spams_wrap', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _spams_wrap = swig_import_helper()
    del swig_import_helper
else:
    import _spams_wrap
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0


def m_ones(nb):
    return _spams_wrap.m_ones(nb)
m_ones = _spams_wrap.m_ones

def skip_space(s):
    return _spams_wrap.skip_space(s)
skip_space = _spams_wrap.skip_space

def parse_line(s, vresult):
    return _spams_wrap.parse_line(s, vresult)
parse_line = _spams_wrap.parse_line

def intlist(s):
    return _spams_wrap.intlist(s)
intlist = _spams_wrap.intlist

def sort(*args):
    """
    sort(Vector< double > * v, bool mode)
    sort(Vector< float > * v, bool mode)
    """
    return _spams_wrap.sort(*args)

def mult(*args):
    """
    mult(Matrix< double > * X, Matrix< double > * Y, Matrix< double > * XY, bool const transX, bool const transY, double const a, double const b)
    mult(Matrix< float > * X, Matrix< float > * Y, Matrix< float > * XY, bool const transX, bool const transY, float const a, float const b)
    """
    return _spams_wrap.mult(*args)

def AAt(*args):
    """
    AAt(SpMatrix< double > * A, Matrix< double > * B)
    AAt(SpMatrix< float > * A, Matrix< float > * B)
    """
    return _spams_wrap.AAt(*args)

def XAt(*args):
    """
    XAt(SpMatrix< double > * A, Matrix< double > * X, Matrix< double > * XAt)
    XAt(SpMatrix< float > * A, Matrix< float > * X, Matrix< float > * XAt)
    """
    return _spams_wrap.XAt(*args)

def applyBayerPattern(*args):
    """
    applyBayerPattern(Vector< double > * v, int offset)
    applyBayerPattern(Vector< float > * v, int offset)
    """
    return _spams_wrap.applyBayerPattern(*args)

def conjugateGradient(*args):
    """
    conjugateGradient(Matrix< double > * A, Vector< double > * b, Vector< double > * x, double const tol, int const itermax)
    conjugateGradient(Matrix< float > * A, Vector< float > * b, Vector< float > * x, float const tol, int const itermax)
    """
    return _spams_wrap.conjugateGradient(*args)

def invSym(*args):
    """
    invSym(Matrix< double > * A)
    invSym(Matrix< float > * A)
    """
    return _spams_wrap.invSym(*args)

def normalize(*args):
    """
    normalize(Matrix< double > * A)
    normalize(Matrix< float > * A)
    """
    return _spams_wrap.normalize(*args)
L1COEFFS = _spams_wrap.L1COEFFS
L2ERROR = _spams_wrap.L2ERROR
PENALTY = _spams_wrap.PENALTY
SPARSITY = _spams_wrap.SPARSITY
L2ERROR2 = _spams_wrap.L2ERROR2
PENALTY2 = _spams_wrap.PENALTY2
FISTAMODE = _spams_wrap.FISTAMODE

def sparseProject(*args):
    """
    sparseProject(Matrix< double > * U, Matrix< double > * V, double const thrs, int const mode, double const lambda1, double const lambda2, double const lambda3, bool const pos, int const numThreads)
    sparseProject(Matrix< float > * U, Matrix< float > * V, float const thrs, int const mode, float const lambda1, float const lambda2, float const lambda3, bool const pos, int const numThreads)
    """
    return _spams_wrap.sparseProject(*args)

def lassoD(*args):
    """
    lassoD(Matrix< double > * X, Matrix< double > * D, bool return_reg_path, int L, double const constraint, double const lambda2, constraint_type mode, bool const pos, bool const ols, int const numThreads, int max_length_path, bool const verbose, bool cholevsky) -> SpMatrix< double >
    lassoD(Matrix< float > * X, Matrix< float > * D, bool return_reg_path, int L, float const constraint, float const lambda2, constraint_type mode, bool const pos, bool const ols, int const numThreads, int max_length_path, bool const verbose, bool cholevsky) -> SpMatrix< float > *
    """
    return _spams_wrap.lassoD(*args)

def lassoQq(*args):
    """
    lassoQq(Matrix< double > * X, Matrix< double > * Q, Matrix< double > * q, bool return_reg_path, int L, double const constraint, double const lambda2, constraint_type mode, bool const pos, bool const ols, int const numThreads, int max_length_path, bool const verbose, bool cholevsky) -> SpMatrix< double >
    lassoQq(Matrix< float > * X, Matrix< float > * Q, Matrix< float > * q, bool return_reg_path, int L, float const constraint, float const lambda2, constraint_type mode, bool const pos, bool const ols, int const numThreads, int max_length_path, bool const verbose, bool cholevsky) -> SpMatrix< float > *
    """
    return _spams_wrap.lassoQq(*args)

def lassoMask(*args):
    """
    lassoMask(Matrix< double > * X, Matrix< double > * D, Matrix< bool > * B, int L, double const constraint, double const lambda2, constraint_type mode, bool const pos, int const numThreads, bool verbose) -> SpMatrix< double >
    lassoMask(Matrix< float > * X, Matrix< float > * D, Matrix< bool > * B, int L, float const constraint, float const lambda2, constraint_type mode, bool const pos, int const numThreads, bool verbose) -> SpMatrix< float > *
    """
    return _spams_wrap.lassoMask(*args)

def lassoWeighted(*args):
    """
    lassoWeighted(Matrix< double > * X, Matrix< double > * D, Matrix< double > * W, int L, double const constraint, constraint_type mode, bool const pos, int const numThreads, bool verbose) -> SpMatrix< double >
    lassoWeighted(Matrix< float > * X, Matrix< float > * D, Matrix< float > * W, int L, float const constraint, constraint_type mode, bool const pos, int const numThreads, bool verbose) -> SpMatrix< float > *
    """
    return _spams_wrap.lassoWeighted(*args)

def omp(*args):
    """
    omp(Matrix< double > * X, Matrix< double > * D, bool return_reg_path, bool given_L, Vector< int > * L, bool given_eps, Vector< double > * eps, bool given_Lambda, Vector< double > * Lambda, int const numThreads) -> SpMatrix< double >
    omp(Matrix< float > * X, Matrix< float > * D, bool return_reg_path, bool given_L, Vector< int > * L, bool given_eps, Vector< float > * eps, bool given_Lambda, Vector< float > * Lambda, int const numThreads) -> SpMatrix< float > *
    """
    return _spams_wrap.omp(*args)

def ompMask(*args):
    """
    ompMask(Matrix< double > * X, Matrix< double > * D, Matrix< bool > * B, bool return_reg_path, bool given_L, Vector< int > * L, bool given_eps, Vector< double > * eps, bool given_Lambda, Vector< double > * Lambda, int const numThreads) -> SpMatrix< double >
    ompMask(Matrix< float > * X, Matrix< float > * D, Matrix< bool > * B, bool return_reg_path, bool given_L, Vector< int > * L, bool given_eps, Vector< float > * eps, bool given_Lambda, Vector< float > * Lambda, int const numThreads) -> SpMatrix< float > *
    """
    return _spams_wrap.ompMask(*args)

def somp(*args):
    """
    somp(Matrix< double > * X, Matrix< double > * D, Vector< int > * groups, int LL, double eps, int numThreads) -> SpMatrix< double >
    somp(Matrix< float > * X, Matrix< float > * D, Vector< int > * groups, int LL, float eps, int numThreads) -> SpMatrix< float > *
    """
    return _spams_wrap.somp(*args)

def cd(*args):
    """
    cd(Matrix< double > * X, Matrix< double > * D, SpMatrix< double > * alpha, double lambda1, constraint_type mode, int itermax, double tol, int numThreads) -> SpMatrix< double >
    cd(Matrix< float > * X, Matrix< float > * D, SpMatrix< float > * alpha, float lambda1, constraint_type mode, int itermax, float tol, int numThreads) -> SpMatrix< float > *
    """
    return _spams_wrap.cd(*args)

def l1L2BCD(*args):
    """
    l1L2BCD(Matrix< double > * X, Matrix< double > * D, Matrix< double > * alpha0, Vector< int > * groups, double lambda1, constraint_type mode, int itermax, double tol, int numThreads)
    l1L2BCD(Matrix< float > * X, Matrix< float > * D, Matrix< float > * alpha0, Vector< int > * groups, float lambda1, constraint_type mode, int itermax, float tol, int numThreads)
    """
    return _spams_wrap.l1L2BCD(*args)
L2 = _spams_wrap.L2
L1L2 = _spams_wrap.L1L2
L1L2FL = _spams_wrap.L1L2FL
L1L2MU = _spams_wrap.L1L2MU

def alltrainDL(*args):
    """
    alltrainDL(Data< double > * X, bool in_memory, bool return_model, Matrix< double > * m_A, Matrix< double > * m_B, int m_iter, Matrix< double > * D1, Vector< double > * eta_g, SpMatrix< bool > * groups, SpMatrix< bool > * groups_var, Vector< int > * own_variables, Vector< int > * N_own_variables, int num_threads, double tol, bool fixed_step, bool ista, int batch_size, int K, double lambda1, double lambda2, double lambda3, int iter, double t0, constraint_type mode, char * name_regul, bool posAlpha, bool posD, bool expand, constraint_type_D modeD, bool whiten, bool clean, bool verbose, double gamma1, double gamma2, double rho, int iter_updateD, bool stochastic, int modeParam, bool batch, bool log, char * logName) -> Matrix< double >
    alltrainDL(Data< float > * X, bool in_memory, bool return_model, Matrix< float > * m_A, Matrix< float > * m_B, int m_iter, Matrix< float > * D1, Vector< float > * eta_g, SpMatrix< bool > * groups, SpMatrix< bool > * groups_var, Vector< int > * own_variables, Vector< int > * N_own_variables, int num_threads, float tol, bool fixed_step, bool ista, int batch_size, int K, double lambda1, double lambda2, double lambda3, int iter, double t0, constraint_type mode, char * name_regul, bool posAlpha, bool posD, bool expand, constraint_type_D modeD, bool whiten, bool clean, bool verbose, double gamma1, double gamma2, float rho, int iter_updateD, bool stochastic, int modeParam, bool batch, bool log, char * logName) -> Matrix< float > *
    """
    return _spams_wrap.alltrainDL(*args)

def archetypalAnalysis(*args):
    """
    archetypalAnalysis(Matrix< double > * X, int p, bool robust, double epsilon, bool computeXtX, int stepsFISTA, int stepsAS, bool randominit, int numThreads) -> Matrix< double >
    archetypalAnalysis(Matrix< float > * X, int p, bool robust, float epsilon, bool computeXtX, int stepsFISTA, int stepsAS, bool randominit, int numThreads) -> Matrix< float > *
    """
    return _spams_wrap.archetypalAnalysis(*args)

def archetypalAnalysisInit(*args):
    """
    archetypalAnalysisInit(Matrix< double > * X, Matrix< double > * Z0, bool robust, double epsilon, bool computeXtX, int stepsFISTA, int stepsAS, int numThreads) -> Matrix< double >
    archetypalAnalysisInit(Matrix< float > * X, Matrix< float > * Z0, bool robust, float epsilon, bool computeXtX, int stepsFISTA, int stepsAS, int numThreads) -> Matrix< float > *
    """
    return _spams_wrap.archetypalAnalysisInit(*args)

def decompSimplex(*args):
    """
    decompSimplex(Matrix< double > * X, Matrix< double > * Z, bool computeXtX, int numThreads) -> SpMatrix< double >
    decompSimplex(Matrix< float > * X, Matrix< float > * Z, bool computeXtX, int numThreads) -> SpMatrix< float > *
    """
    return _spams_wrap.decompSimplex(*args)

def fistaFlat(*args):
    """
    fistaFlat(Matrix< double > * X, AbstractMatrixB< double > * D, Matrix< double > * alpha0, Matrix< double > * alpha, Vector< int > * groups, int num_threads, int max_it, double L0, bool fixed_step, double gamma, double _lambda, double delta, double lambda2, double lambda3, double a, double b, double c, double tol, int it0, int max_iter_backtracking, bool compute_gram, bool lin_admm, bool admm, bool intercept, bool resetflow, char * name_regul, char * name_loss, bool verbose, bool pos, bool clever, bool log, bool ista, bool subgrad, char * logName, bool is_inner_weights, Vector< double > * inner_weights, int size_group, bool sqrt_step, bool transpose, int linesearch_mode) -> Matrix< double >
    fistaFlat(Matrix< float > * X, AbstractMatrixB< float > * D, Matrix< float > * alpha0, Matrix< float > * alpha, Vector< int > * groups, int num_threads, int max_it, float L0, bool fixed_step, float gamma, float _lambda, float delta, float lambda2, float lambda3, float a, float b, float c, float tol, int it0, int max_iter_backtracking, bool compute_gram, bool lin_admm, bool admm, bool intercept, bool resetflow, char * name_regul, char * name_loss, bool verbose, bool pos, bool clever, bool log, bool ista, bool subgrad, char * logName, bool is_inner_weights, Vector< float > * inner_weights, int size_group, bool sqrt_step, bool transpose, int linesearch_mode) -> Matrix< float > *
    """
    return _spams_wrap.fistaFlat(*args)

def fistaTree(*args):
    """
    fistaTree(Matrix< double > * X, AbstractMatrixB< double > * D, Matrix< double > * alpha0, Matrix< double > * alpha, Vector< double > * eta_g, SpMatrix< bool > * groups, Vector< int > * own_variables, Vector< int > * N_own_variables, int num_threads, int max_it, double L0, bool fixed_step, double gamma, double _lambda, double delta, double lambda2, double lambda3, double a, double b, double c, double tol, int it0, int max_iter_backtracking, bool compute_gram, bool lin_admm, bool admm, bool intercept, bool resetflow, char * name_regul, char * name_loss, bool verbose, bool pos, bool clever, bool log, bool ista, bool subgrad, char * logName, bool is_inner_weights, Vector< double > * inner_weights, int size_group, bool sqrt_step, bool transpose, int linesearch_mode) -> Matrix< double >
    fistaTree(Matrix< float > * X, AbstractMatrixB< float > * D, Matrix< float > * alpha0, Matrix< float > * alpha, Vector< float > * eta_g, SpMatrix< bool > * groups, Vector< int > * own_variables, Vector< int > * N_own_variables, int num_threads, int max_it, float L0, bool fixed_step, float gamma, float _lambda, float delta, float lambda2, float lambda3, float a, float b, float c, float tol, int it0, int max_iter_backtracking, bool compute_gram, bool lin_admm, bool admm, bool intercept, bool resetflow, char * name_regul, char * name_loss, bool verbose, bool pos, bool clever, bool log, bool ista, bool subgrad, char * logName, bool is_inner_weights, Vector< float > * inner_weights, int size_group, bool sqrt_step, bool transpose, int linesearch_mode) -> Matrix< float > *
    """
    return _spams_wrap.fistaTree(*args)

def fistaGraph(*args):
    """
    fistaGraph(Matrix< double > * X, AbstractMatrixB< double > * D, Matrix< double > * alpha0, Matrix< double > * alpha, Vector< double > * eta_g, SpMatrix< bool > * groups, SpMatrix< bool > * groups_var, int num_threads, int max_it, double L0, bool fixed_step, double gamma, double _lambda, double delta, double lambda2, double lambda3, double a, double b, double c, double tol, int it0, int max_iter_backtracking, bool compute_gram, bool lin_admm, bool admm, bool intercept, bool resetflow, char * name_regul, char * name_loss, bool verbose, bool pos, bool clever, bool log, bool ista, bool subgrad, char * logName, bool is_inner_weights, Vector< double > * inner_weights, int size_group, bool sqrt_step, bool transpose, int linesearch_mode) -> Matrix< double >
    fistaGraph(Matrix< float > * X, AbstractMatrixB< float > * D, Matrix< float > * alpha0, Matrix< float > * alpha, Vector< float > * eta_g, SpMatrix< bool > * groups, SpMatrix< bool > * groups_var, int num_threads, int max_it, float L0, bool fixed_step, float gamma, float _lambda, float delta, float lambda2, float lambda3, float a, float b, float c, float tol, int it0, int max_iter_backtracking, bool compute_gram, bool lin_admm, bool admm, bool intercept, bool resetflow, char * name_regul, char * name_loss, bool verbose, bool pos, bool clever, bool log, bool ista, bool subgrad, char * logName, bool is_inner_weights, Vector< float > * inner_weights, int size_group, bool sqrt_step, bool transpose, int linesearch_mode) -> Matrix< float > *
    """
    return _spams_wrap.fistaGraph(*args)

def proximalFlat(*args):
    """
    proximalFlat(Matrix< double > * alpha0, Matrix< double > * alpha, Vector< int > * groups, int num_threads, double lambda1, double lambda2, double lambda3, bool intercept, bool resetflow, char * name_regul, bool verbose, bool pos, bool clever, bool eval, int size_group, bool transpose) -> Vector< double >
    proximalFlat(Matrix< float > * alpha0, Matrix< float > * alpha, Vector< int > * groups, int num_threads, float lambda1, float lambda2, float lambda3, bool intercept, bool resetflow, char * name_regul, bool verbose, bool pos, bool clever, bool eval, int size_group, bool transpose) -> Vector< float > *
    """
    return _spams_wrap.proximalFlat(*args)

def proximalTree(*args):
    """
    proximalTree(Matrix< double > * alpha0, Matrix< double > * alpha, Vector< double > * eta_g, SpMatrix< bool > * groups, Vector< int > * own_variables, Vector< int > * N_own_variables, int num_threads, double lambda1, double lambda2, double lambda3, bool intercept, bool resetflow, char * name_regul, bool verbose, bool pos, bool clever, bool eval, int size_group, bool transpose) -> Vector< double >
    proximalTree(Matrix< float > * alpha0, Matrix< float > * alpha, Vector< float > * eta_g, SpMatrix< bool > * groups, Vector< int > * own_variables, Vector< int > * N_own_variables, int num_threads, float lambda1, float lambda2, float lambda3, bool intercept, bool resetflow, char * name_regul, bool verbose, bool pos, bool clever, bool eval, int size_group, bool transpose) -> Vector< float > *
    """
    return _spams_wrap.proximalTree(*args)

def proximalGraph(*args):
    """
    proximalGraph(Matrix< double > * alpha0, Matrix< double > * alpha, Vector< double > * eta_g, SpMatrix< bool > * groups, SpMatrix< bool > * groups_var, int num_threads, double lambda1, double lambda2, double lambda3, bool intercept, bool resetflow, char * name_regul, bool verbose, bool pos, bool clever, bool eval, int size_group, bool transpose) -> Vector< double >
    proximalGraph(Matrix< float > * alpha0, Matrix< float > * alpha, Vector< float > * eta_g, SpMatrix< bool > * groups, SpMatrix< bool > * groups_var, int num_threads, float lambda1, float lambda2, float lambda3, bool intercept, bool resetflow, char * name_regul, bool verbose, bool pos, bool clever, bool eval, int size_group, bool transpose) -> Vector< float > *
    """
    return _spams_wrap.proximalGraph(*args)

def simpleGroupTree(degr):
    """simpleGroupTree(int * degr) -> std::vector< StructNodeElem< double > * > *"""
    return _spams_wrap.simpleGroupTree(degr)

def readGroupStruct(file):
    """readGroupStruct(char const * file) -> std::vector< StructNodeElem< double > * > *"""
    return _spams_wrap.readGroupStruct(file)

def groupStructOfString(data):
    """groupStructOfString(char const * data) -> std::vector< StructNodeElem< double > * > *"""
    return _spams_wrap.groupStructOfString(data)

def graphOfGroupStruct(*args):
    """
    graphOfGroupStruct(std::vector< StructNodeElem< double > * > * gstruct) -> Vector< double >
    graphOfGroupStruct(std::vector< StructNodeElem< float > * > * gstruct) -> Vector< float > *
    """
    return _spams_wrap.graphOfGroupStruct(*args)

def treeOfGroupStruct(*args):
    """
    treeOfGroupStruct(std::vector< StructNodeElem< double > * > * gstruct) -> int
    treeOfGroupStruct(std::vector< StructNodeElem< float > * > * gstruct, Vector< float > ** peta_g) -> int
    """
    return _spams_wrap.treeOfGroupStruct(*args)

def im2col_sliding(*args):
    """
    im2col_sliding(Matrix< double > * A, Matrix< double > * B, int m, int n, bool RGB)
    im2col_sliding(Matrix< float > * A, Matrix< float > * B, int m, int n, bool RGB)
    """
    return _spams_wrap.im2col_sliding(*args)
# This file is compatible with both classic and new-style classes.


